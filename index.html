<!DOCTYPE html>

<html lang="de">
<head>

<style>
/* === Force small cards to stay hidden until we say otherwise === */
.revealCard.small.prehide{
  opacity: 0 !important;
  visibility: hidden !important;
  transform: translateY(24px) scale(.98) !important;
  animation: none !important;
}
</style>

<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1, viewport-fit=cover" name="viewport"/>
<title>Imposter · Vollbild – ohne Karten-Animation</title>
<style>
    :root{
      --txt:#0f172a; --muted:#475569; --border:#e5e7eb;
      --card-fg:#ffffff;
      --card-c1:#6366f1; --card-c2:#22d3ee;
      --grad-start:#ef4444; --grad-end:#f59e0b;
    }
    *{box-sizing:border-box; -webkit-tap-highlight-color:transparent}
    html,body{height:100%}
    body{
      margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
      color:var(--txt);
      background: linear-gradient(160deg,#f3f7ff,#f8fffb);
      -webkit-font-smoothing:antialiased; text-rendering:optimizeLegibility;
      overflow:hidden;
    }
    .stage{width:100vw; height:100svh; display:flex; flex-direction:column; gap:clamp(8px,2vw,16px);
      padding:clamp(10px,2.6vw,22px)}
    header{
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      padding: clamp(8px,1.6vw,14px);
      background:rgba(255,255,255,.65); backdrop-filter:saturate(1.1) blur(4px);
      border:1px solid rgba(15,23,42,.08); border-radius:16px;
      box-shadow:0 10px 28px rgba(15,23,42,.06);
    }
    header h1{margin:0; font-size:clamp(18px,3.6vw,26px)}
    .badge{font-size:12px; padding:6px 10px; border-radius:999px;
      background:linear-gradient(90deg,#c7d2fe,#a7f3d0); color:#0f172a}

    .screens{flex:1; position:relative; min-height:0; overflow:hidden}
    .screen{position:absolute; inset:0; display:none; grid-template-rows:auto 1fr auto; gap:clamp(8px,1.6vw,16px)}
    .screen.active{display:grid}

    @keyframes slideInUp{from{transform:translateY(28px); opacity:0} to{transform:translateY(0); opacity:1}}
    @keyframes fadeOutUp{from{transform:translateY(0); opacity:1} to{transform:translateY(-18px); opacity:0}}
    .entering{animation:slideInUp .45s cubic-bezier(.22,.9,.2,1) forwards}
    .leaving{animation:fadeOutUp .32s cubic-bezier(.33,.85,.4,1) forwards}

    #screenStart, #screenDiscuss{
      background: linear-gradient(180deg, var(--grad-start), var(--grad-end));
      padding: clamp(10px,2.6vw,22px);
      border-radius: 18px;
    }

    .panel{background:#fff; border:1px solid var(--border); border-radius:18px; box-shadow:0 16px 36px rgba(15,23,42,.08);
      padding:clamp(12px,2vw,18px); display:flex; flex-direction:column; gap:clamp(8px,1.4vw,14px)}
    .muted{color:var(--muted)}
    .row{display:flex; gap:12px; align-items:center; justify-content:center; flex-wrap:wrap}

    .btn{appearance:none; border:none; padding:14px 16px; border-radius:14px; cursor:pointer; font-weight:800; color:#fff;
      position:relative; overflow:hidden; transform:translateZ(0); transition:transform .12s cubic-bezier(.2,.8,.2,1), filter .18s ease}
    .btn:active{transform:translateY(1px) scale(.97)}
    .btn-blue{background:linear-gradient(180deg,#60a5fa,#2563eb)}
    .btn-green{background:linear-gradient(180deg,#34d399,#059669)}
    .btn-red{background:linear-gradient(180deg,#fb7185,#ef4444)}
    .btn-lite{background:linear-gradient(180deg,#eef2ff,#e5e7eb); color:#0f172a}
    .btn:disabled{opacity:.5; filter:saturate(.6); cursor:not-allowed}
    .ripple{position:absolute; width:14px; height:14px; border-radius:999px; pointer-events:none; background:rgba(255,255,255,.45);
      transform:translate(-50%,-50%) scale(0); animation:ripple .55s ease-out forwards}
    @keyframes ripple{to{transform:translate(-50%,-50%) scale(24); opacity:0}}

    .btn-next-big{
      min-width:min(320px, 86vw);
      height:64px;
      font-size:clamp(16px, 4.8vw, 20px);
      border-radius:16px;
      padding:0 22px;
      box-shadow:0 16px 36px rgba(37,99,235,.25);
      display:none;
    }
    @keyframes popIn{
      0%{transform:scale(.6); opacity:0}
      60%{transform:scale(1.06); opacity:1}
      100%{transform:scale(1)}
    }
    .pop{animation:popIn .26s cubic-bezier(.2,.9,.2,1) forwards}

    .btn-round{width:56px; height:56px; border-radius:999px; padding:0; display:grid; place-items:center; font-size:28px; line-height:1; letter-spacing:.5px; box-shadow:0 8px 22px rgba(15,23,42,.15);}
    .btn-round:active{transform:translateY(1px) scale(.94)}

    .pill{display:inline-flex; align-items:center; gap:8px; padding:8px 12px; border-radius:999px; background:#eef2ff; color:#0f172a; font-size:13px}
    .num{min-width:64px; text-align:center; padding:12px 0; background:#f3f4f6; border-radius:12px; border:1px solid #e5e7eb; font-weight:800; font-size:20px}
    .name{flex:1; min-width:120px; padding:12px 14px; border:1px solid var(--border); border-radius:12px; font-weight:600; outline:none; background:#fbfdff}

    .coverWrap{position:absolute; inset:0; display:grid; grid-template-rows:auto 1fr auto; gap:clamp(8px,1.6vw,16px)}
    .coverTop{display:flex; align-items:center; justify-content:space-between}
    .coverCard{align-self:stretch; justify-self:stretch; border:1px solid var(--border); border-radius:16px; position:relative; overflow:hidden; box-shadow:0 24px 60px rgba(0,0,0,.12); will-change:transform}
    .underlay{position:absolute; inset:0; z-index:1; display:flex; align-items:flex-end; justify-content:center; pointer-events:none}
    .underBox{width:100%; display:flex; flex-direction:column; align-items:center; gap:10px; padding-bottom:clamp(14px, 5vh, 56px)}
    .word{font-size:clamp(28px, 7vw, 56px); font-weight:900; letter-spacing:.3px; text-align:center; color:#0f172a; margin:0}
    .sub{color:#334155; text-align:center; font-size:clamp(14px, 3.8vw, 18px); margin:0}
    .impostor{color:#ef4444}

    .coverInner{position:absolute; inset:0; z-index:2; display:flex; align-items:center; justify-content:center; touch-action:none; will-change:transform; background: linear-gradient(160deg, var(--card-c1), var(--card-c2));}
    .coverNameBig{position:absolute; inset:0; display:grid; place-items:center; font-weight:900; letter-spacing:.5px; text-transform:uppercase; color:color-mix(in srgb, var(--card-fg) 70%, transparent); font-size:clamp(28px,8vw,48px)}
    .coverHint{position:absolute; bottom:16px; left:50%; transform:translateX(-50%); color:var(--card-fg); background:color-mix(in srgb, var(--card-fg) 15%, transparent); border:1px solid color-mix(in srgb, var(--card-fg) 45%, transparent); padding:8px 12px; border-radius:999px; font-weight:700; font-size:13px}
    .handle{position:absolute; left:50%; top:10px; transform:translateX(-50%); width:80px; height:8px; border-radius:999px; background:color-mix(in srgb, var(--card-fg) 65%, transparent)}

    .votePanel{margin-top:8px; display:flex; flex-direction:column; gap:10px}
    .voteTop{position:sticky; top:0; z-index:2; display:flex; align-items:center; justify-content:space-between; gap:10px; padding:8px 10px; border-radius:12px;
      background:rgba(255,255,255,.85); backdrop-filter:blur(6px); border:1px solid var(--border)}
    .voteTop .left{display:flex; align-items:center; gap:10px; flex-wrap:wrap}
    .voteTop .right{display:flex; align-items:center; gap:8px}
    .remBadge{font-weight:800; padding:6px 10px; border-radius:999px; background:#eef2ff; border:1px solid #e5e7eb}
    #voteScroll{
      max-height:min(62vh, 520px);
      overflow:auto;
      -webkit-overflow-scrolling:touch;
      scroll-behavior:smooth;
      display:block;
    }
    #voteList{display:flex; flex-direction:column; gap:8px}
    @media (min-width: 760px){
      #voteList.twoCols{display:grid; grid-template-columns:1fr 1fr; gap:10px}
    }
    .voteRow{display:flex; align-items:center; justify-content:space-between; padding:10px; border:1px solid var(--border); border-radius:12px; background:#f8fafc}

/* === Gewinner-Highlight (falsch getippt) ohne hässlichen Graurand === */
.voteRow{
  transition: box-shadow .18s ease, background-color .18s ease, border-color .18s ease;
}

.voteRow.win-guess{
  border-color: transparent !important;
  background: #eef2ff; /* leichtes Blau */
  box-shadow:
    0 0 0 3px rgba(59,130,246,.35),
    0 6px 18px rgba(15,23,42,.10);
}

#voteScroll.compact .voteRow.win-guess{
  box-shadow:
    0 0 0 2px rgba(59,130,246,.35),
    0 4px 12px rgba(15,23,42,.08);
  background: #f0f5ff;
}

    .voteName{font-weight:800}
    .voteCtr{display:flex; align-items:center; gap:8px}
    .badgeCnt{min-width:38px; text-align:center; padding:8px 10px; border-radius:10px; background:#e5e7eb; font-weight:800; font-size:16px}
    .voteCtr .btn{min-width:56px; height:56px; border-radius:999px; padding:0; display:grid; place-items:center; font-size:28px; line-height:1; box-shadow:0 8px 22px rgba(15,23,42,.15)}
    .voteCtr .btn:active{transform:translateY(1px) scale(.94)}

    .compact .voteRow{padding:8px}
    .compact .voteName{font-weight:700; font-size:14px}
    .compact .voteCtr .btn{min-width:44px; height:44px; font-size:22px; box-shadow:0 6px 14px rgba(15,23,42,.12)}
    .compact .badgeCnt{min-width:34px; padding:6px 8px; font-size:14px}

    .imp-win{border:2px solid #16a34a !important; background:#ecfdf5 !important; box-shadow:0 0 0 6px rgba(22,163,74,.12)}
    .imp-lose{border:2px solid #ef4444 !important; background:#fff1f2 !important; box-shadow:0 0 0 6px rgba(239,68,68,.12)}
    .wrong-shake{animation:shake .5s cubic-bezier(.36,.07,.19,.97) both}
    @keyframes shake{10%, 90% { transform: translateX(-1px); } 20%, 80% { transform: translateX(2px); } 30%, 50%, 70% { transform: translateX(-4px); } 40%, 60% { transform: translateX(4px); }}

    #confettiCanvas{ position:fixed; inset:0; width:100vw; height:100vh; pointer-events:none; display:none; z-index:99999; }
  






/* Unified Next button behavior: layout-reserved, controlled by JS (no CSS transitions). */
#nextRow{ min-height:72px; } /* ~ Buttonhöhe + etwas Luft */

#screenDeal #btnNext{
  display:block !important;      /* in layout to allow measurement */
  visibility:hidden;             /* hidden by default */
  opacity:0;                     /* fade handled by JS */
  transform: translateY(14px);   /* slight offset until pull */
  transition: none !important;   /* JS positions directly, no CSS animation */
  z-index: 11;                   /* above card */
}

/* Visual overlay: card overlaps reserved area so no visible gap */
:root{ --nextH:72px; }
#nextRow{ 
  min-height: var(--nextH);
  position: relative;
  z-index: 10;
}
#screenDeal .coverCard{
  margin-bottom: calc(-1 * var(--nextH) + 8px);
}

/* When anchored, add bottom padding so text isn't covered by button */
body.btn-anchored #screenDeal .underBox{ padding-bottom: calc( clamp(14px, 5vh, 56px) + var(--nextH, 72px) + 16px ); }
body.btn-anchored #screenDeal .coverCard{ margin-bottom: 8px; }


/* --- Bottom-edge lift animation for coverCard & content when Next button anchors --- */
#screenDeal .coverCard{
  transition: margin-bottom .32s cubic-bezier(.2,.9,.2,1.2), transform .28s cubic-bezier(.2,1,.36,1), box-shadow .28s ease;
}
#screenDeal .underBox{
  transition: padding-bottom .32s cubic-bezier(.2,.9,.2,1.2);
}
/* Subtle shadow/lift when anchored */
body.btn-anchored #screenDeal .coverCard{
  box-shadow:0 28px 60px rgba(0,0,0,.14);
}


/* Softere Unterkante beim Anheben */
body.btn-anchored #screenDeal .coverCard{ border-bottom-left-radius:22px; border-bottom-right-radius:22px; }


/* Smooth fades for the Next button */
#screenDeal #btnNext{
  transition: opacity .22s ease, transform .22s ease;
}
#screenDeal #btnNext.btn-fading{
  opacity: 0;
  pointer-events: none;
}

/* Ease the anchored layout change so it doesn't "cut" */
#screenDeal .coverCard{
  transition: margin-bottom .24s ease, box-shadow .24s ease;
}
#screenDeal .underBox{
  transition: padding-bottom .24s ease;
}


/* --- Pop-in Animation for player inputs --- */
/* --- Pop-out Animation for removing player inputs --- */
@keyframes popOut {
  0%   { transform: scale(1); opacity: 1; }
  40%  { transform: scale(1.04); }
  100% { transform: scale(0.6); opacity: 0; }
}
#namesWrap .name.pop-out {
  animation: popOut 0.20s cubic-bezier(.22,1,.36,1) forwards;
  transform-origin: center;
  will-change: transform, opacity;
}

@keyframes popIn {
  0%   { transform: scale(0.6); opacity: 0; }
  60%  { transform: scale(1.05); opacity: 1; }
  100% { transform: scale(1); }
}
#namesWrap .name.pop-in {
  animation: popIn 0.22s cubic-bezier(.22,1,.36,1);
  transform-origin: center;
  will-change: transform, opacity;
}





/* === Impostor shake animation === */
@keyframes impostorShake {
  0% { transform: translate(0, 0) rotate(0deg); }
  20% { transform: translate(-1px, 1px) rotate(-1deg); }
  40% { transform: translate(-1px, -1px) rotate(1deg); }
  60% { transform: translate(1px, 1px) rotate(0deg); }
  80% { transform: translate(1px, -1px) rotate(1deg); }
  100% { transform: translate(0, 0) rotate(0deg); }
}
#wordOut.impostor {
  animation: impostorShake 0.4s infinite;
}
/* === end impostor shake === */





/* === Pulse animation for normal words (visible & gentle) === */
@keyframes wordPulseNormal {
  0%   { transform: scale(0.98); opacity: 0.88; }
  50%  { transform: scale(1.06); opacity: 1; }
  100% { transform: scale(1);    opacity: 0.95; }
}
#screenDeal .underlay .word.pulse-normal{
  animation: wordPulseNormal 0.6s cubic-bezier(.22,1,.36,1);
  transform-origin: center bottom;
  will-change: transform, opacity;
}
/* === end pulse animation === */


/* === Larger dynamic text sizes === */
#wordOut {
  font-size: clamp(2.5rem, 6vw, 5rem);
  line-height: 1.2;
}
#subOut {
  font-size: clamp(1.2rem, 3vw, 2rem);
  line-height: 1.3;
}
/* === end larger text === */





/* === Idle wiggle animation for coverInner (10s inactivity) === */
@keyframes idleWiggle {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-4px); }
}
#coverInner.idle-wiggle {
  animation: idleWiggle 0.6s ease-in-out infinite;
  will-change: transform;
}
/* === end idle wiggle === */


/* === Rounded colorful inner corners === */
#coverInner {
  border-radius: inherit;
  overflow: hidden;
}
/* === end rounded corners === */


/* === Match coverInner background to card === */
#coverInner {
  background-color: inherit; /* use parent's background color */
}
/* === end match === */


/* === Remove card shadow === */
#coverCard {
  box-shadow: none !important;
}
/* === end remove shadow === */


/* === Chart mode styles for voting results === */
#voteList.chart-mode .voteRow{
  display: grid;
  grid-template-columns: 1fr auto;
  align-items: center;
  gap: 12px;
}
#voteList.chart-mode .voteRow .voteCtr{
  opacity: 0;
  transform: scale(0.92);
  transition: opacity .28s ease, transform .28s ease;
}
#voteList.chart-mode .voteRow .voteName{
  justify-self: end;
  font-weight: 900;
}
#voteList.chart-mode .voteRow .barWrap{
  position: relative;
  height: 14px;
  background: #e5e7eb;
  border-radius: 999px;
  overflow: hidden;
}
#voteList.chart-mode .voteRow .bar{
  position: absolute;
  left: 0; top: 0; bottom: 0;
  width: 0%;
  background: #3b82f6; /* blue bars */
  border-radius: 999px;
  transition: width .8s cubic-bezier(.22,1,.36,1);
}
#voteList.chart-mode .voteRow .barValue{
  position: absolute;
  right: 8px; top: 50%;
  transform: translateY(-50%);
  font-size: 12px;
  font-weight: 800;
  color: #ffffff;
  text-shadow: 0 1px 1px rgba(0,0,0,.25);
  pointer-events: none;
}
/* Slight compact tweaks in compact mode */
#voteScroll.compact #voteList.chart-mode .voteRow .barWrap{ height: 12px; }
#voteScroll.compact #voteList.chart-mode .voteRow{ gap: 10px; }
/* === end chart mode === */


@keyframes slideUpModal {
  from { transform: translateY(100%); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
}


/* === Voting round reset animation === */
@keyframes voteFadeOut {
  0% { transform: scale(1); opacity: 1; }
  60% { transform: scale(1.02); }
  100% { transform: scale(0.96); opacity: 0; }
}
@keyframes voteFadeIn {
  0% { transform: scale(0.96); opacity: 0; }
  60% { transform: scale(1.04); }
  100% { transform: scale(1); opacity: 1; }
}
#voteList.vote-resetting .voteRow { animation: voteFadeOut .28s cubic-bezier(.22,1,.36,1) both; }
#voteList.vote-reset-done .voteRow { animation: voteFadeIn .26s cubic-bezier(.22,1,.36,1) both; }


/* === Quadratische Mini-Reveal-Karten (mehrere Impostors) === */
#revealArea.multi {
  display: grid;
  grid-template-columns: repeat(2, 1fr); /* genau 2 nebeneinander */
  gap: 12px; /* gleichmäßiger Abstand zwischen den Karten */
  justify-items: center; /* Karten mittig innerhalb der Spalte */
}

.revealCard.small {
  aspect-ratio: 1 / 1; /* macht sie quadratisch */
  width: 100%;
  max-width: 200px; /* verhindert, dass sie zu groß werden */
  display: grid;
  place-items: center;
  padding: 12px;
}

/* Optional: Text sauber umbrechen */
.revealCard.small * {
  text-wrap: balance;
}
</style>
<style>
/* Smooth Crossfade override (safe append) */
.coverCard .underlay,
.coverCard .coverInner{
  will-change: opacity, transform;
}

.swap-fade{
  transition: opacity .18s ease, transform .18s ease;
}

.is-hidden{
  opacity: 0;
  transform: translateY(-8px);
}
</style>
<style>
/* Ensure sliding is clipped within the card */
#coverCard{ overflow: hidden; }

#coverCard.stretching {
  padding-top: 189px; /* ≈5 cm */
  transition: padding-top 0.25s ease;
}

</style>
<style>
/* Slide-up animation for the Weitergeben button */
@keyframes btnNextSlideUp {
  0% {
    transform: translateY(120%);
    opacity: 0;
  }
  100% {
    transform: translateY(0);
    opacity: 1;
  }
}
#btnNext.btn-animate-in {
  animation: btnNextSlideUp 0.35s cubic-bezier(.22,1,.36,1) forwards;
}
</style>
<style>
/* Safer slide-up: animate the container instead of the button to avoid conflicts */
@keyframes nextRowSlideUp {
  0% { transform: translateY(140%); opacity: 0; }
  100% { transform: translateY(0); opacity: 1; }
}
#nextRow.animate-in {
  animation: nextRowSlideUp 0.35s cubic-bezier(.22,1,.36,1) both;
  will-change: transform, opacity;
}
</style>
<style>
/* --- Next button smoothing & no-pop overrides --- */

/* Kill the pop animation if any script adds the class */
#btnNext.pop { animation: none !important; }
/* Ensure no keyframe-driven scale-jump affects the button */
#btnNext { will-change: transform, opacity; transition: transform .18s ease, opacity .18s ease, filter .18s ease; }
/* Prevent scale-down on press for this button to keep it calm */
#btnNext:active { transform: translateY(0) !important; }
/* Keep edges crisp during transforms */
#btnNext { backface-visibility: hidden; transform: translateZ(0); }
</style>
<style>
/* Force-hide underlay text while transitioning to next card */
body.underlay-hidden #screenDeal .underlay{
  visibility: hidden !important;
  opacity: 0 !important;
}
</style>
<style>
/* --- Last-player pulse when total is odd and final player is shown --- */
@keyframes fullWidthPulse {
  0%   { transform: scale(1); box-shadow: 0 0 0 rgba(255,255,255,0); }
  50%  { transform: scale(1.02); box-shadow: 0 0 28px rgba(255,255,255,0.60); }
  100% { transform: scale(1); box-shadow: 0 0 0 rgba(255,255,255,0); }
}
#coverCard.fullwidth-anim {
  animation: fullWidthPulse 0.8s ease-out forwards;
}
</style>
<style>
/* === Flip Reveal (robust) === */
#coverCard{ perspective: 1000px; transform-style: preserve-3d; }
#coverCard.flip-tilt{
  transform: rotateX(16deg);
  transition: transform .22s cubic-bezier(.22,1,.36,1);
  will-change: transform;
  transform-origin: center bottom;
}
#coverCard.flip-tilt.release{ transform: rotateX(0deg); }
</style>
<style>
/* === Word pulse animation under the card === */
@keyframes wordPulse {
  0%   { transform: scale(0.96); text-shadow: none; }
  50%  { transform: scale(1.04); }
  100% { transform: scale(1); }
}
#screenDeal .underlay .word.pulse{
  animation: wordPulse .55s cubic-bezier(.22,1,.36,1);
  will-change: transform;
}

/* Particle canvas inside the underlay */
#screenDeal .underlay canvas.imp-particles{
  position:absolute;
  inset:0;
  width:100%;
  height:100%;
  pointer-events:none;
  z-index:0;
}
</style>
<style>
/* === v11 includes v9 Overlay-Bar-Chart (Frames bleiben unverändert) === */
#voteList.chart-mode .voteRow { position: relative; }

#voteList.chart-mode .voteRow .voteName,
#voteList.chart-mode .voteRow .voteCtr {
  visibility: hidden;
  opacity: 0;
  transition: opacity .25s ease;
  pointer-events: none;
}

#voteList.chart-mode .voteRow .barOverlay {
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  gap: 12px;
  opacity: 0;
  transform: translateY(6px);
  transition: opacity .32s ease, transform .32s ease;
  pointer-events: none;
  padding: 0;
}

#voteList.chart-mode .voteRow .barWrap {
  position: relative;
  height: 14px;
  background: #e5e7eb;
  border-radius: 999px;
  overflow: hidden;
  flex: 1;
}
#voteList.chart-mode .voteRow .bar {
  position: absolute;
  left: 0; top: 0; bottom: 0;
  width: 0%;
  background: linear-gradient(90deg, #3b82f6, #6366f1); /* v10 gloss */
  border-radius: 999px;
  transition: width .8s cubic-bezier(.22,1,.36,1);
}
#voteList.chart-mode .voteRow .barWrap{ box-shadow: inset 0 1px 2px rgba(0,0,0,.06); }
#voteList.chart-mode .voteRow .barValue {
  position: absolute;
  right: 8px; top: 50%;
  transform: translateY(-50%);
  font-size: 12px;
  font-weight: 800;
  color: #fff;
  text-shadow: 0 1px 1px rgba(0,0,0,.25);
  pointer-events: none;
}
#voteList.chart-mode .voteRow .nameGhost {
  font-weight: 900;
  white-space: nowrap;
}
#voteScroll.compact #voteList.chart-mode .voteRow .barWrap { height: 12px; }
</style>
<style>
/* === v11 includes v10 UI Polish: Smoother, cleaner Vote-Screen === */
.voteRow{
  transition: background-color .18s ease, border-color .18s ease, box-shadow .22s ease, transform .22s ease;
}
.voteRow:hover,
.voteRow:focus-within{
  background: #ffffff;
  box-shadow: 0 10px 24px rgba(15,23,42,.08);
  transform: translateY(-1px);
}
.voteCtr .btn{
  transition: transform .12s ease, box-shadow .18s ease, filter .18s ease;
}
.voteCtr .btn:hover{
  transform: translateY(-1px);
  box-shadow: 0 10px 24px rgba(15,23,42,.12);
}
.voteCtr .btn:active{ transform: translateY(0); }
.badgeCnt{
  transition: background-color .18s ease, transform .18s cubic-bezier(.2,1,.36,1);
  will-change: transform;
}
.badgeCnt.pulse{
  transform: scale(1.08);
  background: #dbeafe;
}
.voteTop{
  backdrop-filter: blur(8px) saturate(1.05);
  border-color: rgba(15,23,42,.08);
  box-shadow: 0 8px 18px rgba(15,23,42,.06);
}
#voteScroll{
  scrollbar-width: thin;
  scrollbar-color: #cbd5e1 transparent;
}
#voteScroll::-webkit-scrollbar{ height: 10px; width: 10px; }
#voteScroll::-webkit-scrollbar-thumb{ background: #cbd5e1; border-radius: 999px; }
#voteScroll::-webkit-scrollbar-track{ background: transparent; }
#voteScroll.compact .voteRow{ border-radius: 10px; }
#voteScroll.compact .voteName{ font-weight: 800; letter-spacing: .1px; }

@media (prefers-reduced-motion: reduce){
  .voteRow, .voteCtr .btn, .badgeCnt,
  #voteList.chart-mode .voteRow .barWrap,
  #voteList.chart-mode .voteRow .barOverlay{
    transition: none !important;
    animation: none !important;
  }
}
</style>
<style>
/* === v14: Lift-Effekt nur beim PLUS-Klick === */

/* 1) Deaktiviere generelles Hover/Fokus-Lift auf der ganzen Row */
.voteRow:hover,
.voteRow:focus-within{
  background: inherit !important;
  box-shadow: none !important;
  transform: none !important;
}

/* 2) Definiere eine kurze, sanfte "Bump"-Klasse für die Row,
      die wir nur beim + Klick temporär setzen */
.voteRow.bump{
  background: #ffffff;
  box-shadow: 0 10px 24px rgba(15,23,42,.08);
  transform: translateY(-1px);
  transition: background-color .18s ease, border-color .18s ease, box-shadow .22s ease, transform .22s ease;
}
</style>
<style>
/* === v15: Diagramm-Balken breiter+höher und Name darüber === */

/* BarWrap höher, aber Balken kürzer in der Länge durch padding */
#voteList.chart-mode .voteRow .barOverlay {
  flex-direction: column;
  align-items: flex-start;
  gap: 4px;
  padding: 6px 8px;
}
#voteList.chart-mode .voteRow .nameGhost {
  order: -1;
  font-size: 0.85rem;
  font-weight: 700;
  white-space: nowrap;
}
#voteList.chart-mode .voteRow .barWrap {
  width: 95%; /* kürzer als volle Breite */
  height: 18px; /* etwas höher */
}
#voteScroll.compact #voteList.chart-mode .voteRow .barWrap {
  height: 16px;
}

/* === Mode selection cards === */
.modeWrap{ padding: clamp(10px,2.6vw,22px); }
.modeHeader{ display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:12px; }
.modeHeader h2{ margin:0; }
.modeClose{ appearance:none; border:none; background:transparent; font-size:22px; line-height:1; padding:8px; cursor:pointer; border-radius:10px; }
.modeClose:active{ transform: translateY(1px); }

.modeGrid{ display:grid; grid-template-columns: 1fr; gap:12px; }
@media(min-width:720px){ .modeGrid{ grid-template-columns: 1fr 1fr; } }

.modeCard{ position:relative; background:#fff; border:2px solid var(--border); border-radius:16px; box-shadow:0 10px 26px rgba(15,23,42,.08);
  padding:16px; cursor:pointer; transition: border-color .18s ease, box-shadow .22s ease, transform .12s ease; }
.modeCard:hover{ transform: translateY(-1px); box-shadow:0 14px 30px rgba(15,23,42,.10); }
.modeCard.selected{ border-color:#16a34a; box-shadow:0 0 0 4px rgba(22,163,74,.18), 0 16px 34px rgba(15,23,42,.12); }

.modeTag{ position:absolute; top:10px; right:10px; font-weight:900; font-size:13px; padding:6px 10px; border-radius:999px;
  background:#eef2ff; color:#0f172a; border:1px solid #e5e7eb; }
.modeTitle{ margin:22px 0 8px; font-size:18px; font-weight:900; }
.modeDesc{ margin:0; color:var(--muted); line-height:1.35; }

/* Fix: tag only top-left */
.modeTag{ left:10px; right:auto; }
/* Hide duplicate large title line to avoid double naming */
.modeTitle{ display:none; }
/* Ensure mode screen overlays properly */
#screenMode{ z-index: 20; }
/* Bounce slide-up animation for mode screen */
@keyframes slideUpBounce {
  0%   { transform: translateY(100%); opacity: 0; }
  60%  { transform: translateY(-6%); opacity: 1; }
  80%  { transform: translateY(3%);  }
  100% { transform: translateY(0);   }
}
/* Use bounce when this screen enters */
#screenMode.entering{
  animation: slideUpBounce .5s cubic-bezier(.2,1,.36,1) both !important;
}

/* Card content layout tweaks */
.modeTitle{ display:none !important; } /* remove big title above description */
.modeDesc{ margin-top: 28px !important; } /* create space under the top-left tag */
.modeTag{ position:absolute; top:10px; left:10px; right:auto; } /* keep tag only top-left */

/* Dedicated, non-conflicting animations for the mode screen */
@keyframes modeSlideUp {
  0%   { transform: translateY(100%); opacity: 0; }
  60%  { transform: translateY(-4%); opacity: 1; }
  80%  { transform: translateY(2%);  }
  100% { transform: translateY(0);   }
}
@keyframes modeSlideDown {
  0%   { transform: translateY(0);   opacity: 1; }
  100% { transform: translateY(100%); opacity: 0; }
}
/* Override generic screen animations ONLY for screenMode */
#screenMode.entering{ animation: modeSlideUp .42s cubic-bezier(.22,1,.36,1) both !important; }
#screenMode.leaving{ animation: modeSlideDown .28s ease both !important; }

/* Red close (X) button styling */
.modeClose{
  background: linear-gradient(180deg,#fb7185,#ef4444) !important;
  color:#fff !important;
  border:1px solid rgba(239,68,68,.6) !important;
  border-radius:12px !important;
  font-weight:900 !important;
  box-shadow:0 8px 18px rgba(239,68,68,.25);
}
.modeClose:hover{ filter:saturate(1.05) brightness(1.02); }
.modeClose:active{ transform: translateY(1px); }

@keyframes modeSlideUpSimple {
  from { transform: translateY(100%); opacity: 0; }
  to   { transform: translateY(0);   opacity: 1; }
}
@keyframes modeSlideDownSimple {
  from { transform: translateY(0);   opacity: 1; }
  to   { transform: translateY(100%); opacity: 0; }
}
#screenMode.entering{ animation: modeSlideUpSimple .28s ease-out both !important; }
#screenMode.leaving{  animation: modeSlideDownSimple .22s ease-in  both !important; }

/* --- Stable slide for mode screen (no bounce, no double-anim) --- */
#screenMode{ transform: translateY(100%); animation: none !important; will-change: transform, opacity; }
#screenMode.active{ transform: translateY(0); }
@keyframes modeSlideUpStable { from { transform: translateY(100%); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
@keyframes modeSlideDownStable { from { transform: translateY(0); opacity: 1; } to { transform: translateY(100%); opacity: 0; } }
#screenMode.entering{ animation: modeSlideUpStable .24s ease-out both !important; }
#screenMode.leaving{  animation: modeSlideDownStable .18s ease-in  both !important; }
/* Avoid inner elements adding their own motion during screen enter */
#screenMode .panel, #screenMode .modeCard, #screenMode .modeWrap{ animation: none !important; transition: none; }
</style>
<style>
/* === Smooth slide for Mode Screen (no bounce, GPU-friendly) === */
#screenMode{
  will-change: transform, opacity;
  backface-visibility: hidden;
  transform: translateY(100%);
  opacity: 0;
}
#screenMode.active{
  transform: translateY(0);
  opacity: 1;
}

/* Keyframes tuned with gentle easing */
@keyframes modeSlideUpSmooth {
  0%   { transform: translateY(100%); opacity: 0.01; }
  60%  { transform: translateY(2%);   opacity: 1; }
  100% { transform: translateY(0);    opacity: 1; }
}
@keyframes modeSlideDownSmooth {
  0%   { transform: translateY(0);    opacity: 1; }
  100% { transform: translateY(100%); opacity: 0; }
}

/* Apply with slightly longer durations and high-quality easing */
#screenMode.entering{
  animation: modeSlideUpSmooth .34s cubic-bezier(.22,1,.36,1) both !important;
}
#screenMode.leaving{
  animation: modeSlideDownSmooth .26s cubic-bezier(.4,0,.2,1) both !important;
}

/* Avoid inner element transitions while the screen animates to prevent micro-jitters */
#screenMode.entering .panel,
#screenMode.entering .modeCard,
#screenMode.entering .modeWrap,
#screenMode.leaving .panel,
#screenMode.leaving .modeCard,
#screenMode.leaving .modeWrap{ transition: none !important; animation: none !important; }

/* Respect reduced motion */
@media (prefers-reduced-motion: reduce){
  #screenMode{ transition: none !important; animation: none !important; transform: translateY(0) !important; opacity: 1 !important; }
}
</style>
<style>
/* === FIX: No top "cut" when the mode screen animates in/out === */
/* Make the mode screen fully opaque during the slide so nothing underneath flashes through */
#screenMode.entering,
#screenMode.leaving{
  background: #ffffff !important;
}

/* Avoid opacity fade at start; only slide. This prevents any brief transparency. */
#screenMode.entering{
  opacity: 1 !important;
  animation: modeSlideUpNoCut .28s cubic-bezier(.22,1,.36,1) both !important;
}
#screenMode.leaving{
  opacity: 1 !important;
  animation: modeSlideDownNoCut .22s ease-in both !important;
}

/* New keyframes focused purely on translateY */
@keyframes modeSlideUpNoCut {
  from { transform: translateY(100%); }
  to   { transform: translateY(0); }
}
@keyframes modeSlideDownNoCut {
  from { transform: translateY(0); }
  to   { transform: translateY(100%); }
}

/* Keep everything clipped within the screens container just in case */
.screens{ overflow: hidden !important; }
</style>
<style>
/* === FIX: Ensure mode screen covers header instantly (no top flash or arrow) === */
#screenMode {
  position: absolute !important;
  inset: 0 !important; /* cover from very top to bottom */
  height: 100% !important;
  background: #ffffff !important; /* full opaque white */
  z-index: 999 !important; /* above header */
}
/* Ensure parent container doesn't clip early */
.screens {
  overflow: hidden !important;
  position: relative !important;
}
</style>

<style>
/* === Animated Reveal Cards === */
#revealArea{
  margin-top: 10px;
  display: grid;
  gap: 12px;
  justify-content: center;
}
#revealArea.single{
  display: flex;
  align-items: center;
  justify-content: center;
}
.revealCard{
  background: #ffffff;
  border: 2px solid #e5e7eb;
  border-radius: 16px;
  box-shadow: 0 14px 34px rgba(15,23,42,.12);
  padding: 14px 16px;
  font-weight: 900;
  letter-spacing: .2px;
  color: #0f172a;
  opacity: 0;
  transform: translateY(24px) scale(.98);
  animation: revealPop .42s cubic-bezier(.22,1,.36,1) forwards;
}
/* Big single card */
.revealCard.big{
  min-width: min(520px, 92vw);
  text-align: center;
  font-size: clamp(22px, 5.4vw, 30px);
  border-width: 3px;
  background: linear-gradient(160deg,#fef3c7,#fecaca);
  border-color: rgba(251,146,60,.55);
  box-shadow: 0 18px 44px rgba(249,115,22,.22);
}
/* Small grid cards */
.revealCard.small{
  min-width: 160px;
  text-align: center;
  font-size: clamp(14px, 3.8vw, 18px);
  background: linear-gradient(160deg,#eff6ff,#ede9fe);
  border-color: rgba(59,130,246,.45);
  box-shadow: 0 12px 28px rgba(59,130,246,.18);
}
/* Staggered animation */
@keyframes revealPop{
  0%{ opacity:0; transform: translateY(24px) scale(.98); }
  60%{ opacity:1; transform: translateY(-2px) scale(1.02); }
  100%{ opacity:1; transform: translateY(0) scale(1); }
}

/* Grid layout to follow the pattern:
   1st top-right under the button, 2nd next to it, 3rd under 1st, 4th under 2nd, etc.
   We'll implement with 2 columns and place new cards column-wise. */
#revealArea.multi{
  grid-template-columns: repeat(2, minmax(140px, 220px));
  align-items: start;
}
/* Badge look for impostor tag inside cards */
.revealTag{
  display:inline-block;
  margin-top: 6px;
  padding: 6px 10px;
  border-radius: 999px;
  font-size: 12px;
  font-weight: 800;
  background:#fee2e2;
  color:#991b1b;
  border:1px solid #fecaca;
}
</style>

<style>
/* === v5: Strong overlay reveal (cards only) === */
#revealOverlay {
  position: absolute;
  top: calc(1cm + 100px); /* keep top offset to clear top bar */
  left: 50%;
  transform: translateX(-50%);
  bottom: 1cm;
  display: none;
  
  pointer-events: none;
  display: flex;
  align-items: center;
  justify-content: center;
  width: calc(100% - clamp(20px, 5.2vw, 44px)); /* match white panel width */
}

#revealOverlay.show { display: flex; }

#revealOverlay .cardBig {
  width: calc(100% - 1cm);
  margin: 0 auto;
  height: 100%;
  max-height: 100%;
  border-radius: 18px;
  background: linear-gradient(160deg,#fde68a,#fecaca);
  border: 3px solid rgba(234,88,12,.55);
  box-shadow: 0 22px 60px rgba(234,88,12,.28);
  color: #0f172a;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: clamp(10px, 2vw, 20px);
  text-align: center;
  font-weight: 900;
  letter-spacing: .3px;
  opacity: 0;
  transform: translateY(16px) scale(.98);
  animation: cardScrollDown 0.65s cubic-bezier(0,0,0.2,1) forwards;
}

@keyframes cardFadeIn {
  0%   { opacity: 0; transform: translateY(16px) scale(.98); }
  60%  { opacity: 1; transform: translateY(-2px) scale(1.01); }
  100% { opacity: 1; transform: translateY(0) scale(1); }
}

.revealTitle { font-size: clamp(22px, 5.4vw, 32px); }
.revealWord  { font-size: clamp(18px, 4.6vw, 26px); }
.revealTagBig{
  display:inline-block;
  padding: 8px 12px;
  border-radius: 999px;
  background:#fee2e2;
  border:1px solid #fecaca;
  font-size: clamp(12px, 3.6vw, 14px);
  font-weight: 800;
  color:#991b1b;
}
</style>

<style>

@keyframes cardScrollDown { 0%{opacity:0; transform: translateY(-24px);} 100%{opacity:1; transform: translateY(0);} }
  100% { opacity: 1; transform: translateY(0); }
}
  60%  { opacity: 1; transform: translateY(6px)  scale(1.01); }
  100% { opacity: 1; transform: translateY(0)    scale(1); }
}
@media (prefers-reduced-motion: reduce){
  #revealOverlay .cardBig{ animation: cardScrollDown 0.65s cubic-bezier(0,0,0.2,1) forwards; opacity: 1 !important; transform: none !important; }
}

</style>
<style>

/* Keep the top white bar above the reveal card during animation */
#screenDiscuss .panel:first-of-type{
  position: relative;
  z-index: 200;
}

/* Overlay under the bar so it slides out from beneath */
#revealOverlay{
   /* lower than the bar */
}

</style>

<style>
/* === Expand the top bar in the Vote screen downward when "Auflösen" is pressed === */
/* We mark the first panel in #screenDiscuss as the reveal bar at runtime (JS below). */
#screenDiscuss .panel.revealbar{
  transition: padding-bottom .32s cubic-bezier(.22,1,.36,1);
  will-change: padding-bottom;
}
/* ~3x height effect: add extra space below without moving the button up */
#screenDiscuss .panel.revealbar.expanded{
  padding-bottom: calc(var(--nextH, 72px) * 2);
}
</style>


<style>
/* === Dynamic expand behavior for Vote top bar (no overlap with reveal) === */
#screenDiscuss .panel.revealbar{
  transition: padding-bottom .32s cubic-bezier(.22,1,.36,1);
  will-change: padding-bottom;
  position: relative; /* keep it in normal flow */
  z-index: 200;       /* above overlays that are set lower */
}
/* Keep overlay under the bar so it slides out from beneath */
#revealOverlay{  }
</style>


<style>
/* Overlay must stay on top of the expanding bar; do NOT move it */
#revealOverlay{ z-index: 9999 !important; }
</style>


<style>
/* The top vote panel should sit below the overlay so the card is always visible */
#screenDiscuss .panel.revealbar{ z-index: 100 !important; }
</style>


<style>
/* === Overlay-Grid für MULTI-Reveal (verhindert Verschieben durch Top-Bar) === */
#revealOverlay.multi {
  display: flex !important;
  align-items: flex-start;
  justify-content: center;
}

#revealOverlay .gridWrap {
  display: grid;
  grid-template-columns: repeat(2, minmax(140px, 220px));
  gap: 12px;
  justify-items: center;
  align-items: start;
  width: auto;
  max-width: calc(100% - clamp(20px, 5.2vw, 44px));
}

/* Karten im Overlay behalten den small-Style */
#revealOverlay .revealCard.small{
  background: linear-gradient(160deg,#eff6ff,#ede9fe);
  border: 2px solid rgba(59,130,246,.45);
  border-radius: 16px;
  box-shadow: 0 12px 28px rgba(59,130,246,.18);
  padding: 12px 14px;
  font-weight: 900;
  letter-spacing: .2px;
  color: #0f172a;
  text-align: center;
  min-width: 160px;
  font-size: clamp(14px, 3.8vw, 18px);
}
</style>


<style>

/* Sichtbarkeit wiederhergestellt */
#voteResult {
  display: block !important;
  visibility: visible !important;
  height: auto !important;
  padding: initial !important;
  margin: 4px 0 0 0 !important;
}
#revealBox {
  display: block !important;
}

</style>


<style>
/* === SINGLE REVEAL: smooth pop-in for big card (on-demand) === */
#revealOverlay .cardBig.pop-in {
  animation: cardBigPopIn 0.38s cubic-bezier(.2,1,.36,1) forwards;
}
@keyframes cardBigPopIn {
  0%   { transform: translateY(8px) scale(0.88); opacity: 0; }
  60%  { transform: translateY(-2px) scale(1.05); opacity: 1; }
  100% { transform: translateY(0) scale(1); }
}
</style>


<style>
/* === SINGLE REVEAL: falling-in animation (gravity-like with tiny bounce) === */
#revealOverlay .cardBig.fall-in {
  animation: cardBigFallIn 0.48s cubic-bezier(.2,1,.36,1) forwards;
}
@keyframes cardBigFallIn {
  0%   { transform: translateY(-28px) scale(0.98); opacity: 0; filter: blur(0.6px); }
  55%  { transform: translateY(6px)  scale(1.01); opacity: 1; filter: blur(0); }
  78%  { transform: translateY(-2px) scale(1.0); }
  100% { transform: translateY(0)    scale(1.0); }
}
</style>


<style>
/* === SINGLE REVEAL: position tweak - 0.5cm gap below card to bar === */
#revealOverlay .cardBig {
  margin-bottom: 0.5cm !important;
}
</style>


<style>
/* === FIXED OLD EDGE LINE (stays at the same screen position) === */
#oldEdgeLine {
  position: fixed;
  left: 0;
  right: 0;
  height: 2px;
  background: rgba(0,0,0,0.25);
  box-shadow: 0 1px 4px rgba(0,0,0,0.12);
  z-index: 99999;
  pointer-events: none;
  display: none; /* becomes visible on reveal */
}
</style>


<style>
/* Cleanup: ensure any old fixed line stays hidden */
#oldEdgeLine { display: none !important; }
</style>


<style>
/* === Revealbar: make expanded part look like it slides from under the old edge === */
/* The expanded space is added via extra padding-bottom. We place a pseudo edge at (bottom - padding-bottom) */
#screenDiscuss .panel.revealbar {
  position: relative;
}

#screenDiscuss .panel.revealbar.expanded::after {
  content: "";
  position: absolute;
  left: 0;
  right: 0;
  height: 0;                   /* line-like emitter */
  bottom: calc(var(--nextH, 72px) * 2); /* position at old edge: bottom minus added padding */
  box-shadow: 0 8px 18px rgba(0,0,0,0.20); /* cast shadow downwards onto the sliding part */
  pointer-events: none;
  z-index: 5;
}

/* If different padding is used somewhere (fallback), approximate with 0.5cm */
@supports not (bottom: calc(var(--nextH, 72px) * 2)) {
  #screenDiscuss .panel.revealbar.expanded::after {
    bottom: 0.5cm;
  }
}
</style>


<style>
/* Subtle inner fade below the old edge to deepen the effect */
#screenDiscuss .panel.revealbar.expanded {
  background: linear-gradient(to bottom, rgba(0,0,0,0.06), transparent 16px) #fff;
  background-clip: padding-box;
}
</style>


<style>
/* === Update: match top edge radius of old bar for shadow start === */
#oldEdgeShadow {
  border-top-left-radius: 0;   /* will be set dynamically */
  border-top-right-radius: 0;  /* will be set dynamically */
}
</style>




<style>
#coverHint {
  display: none !important;
  visibility: hidden !important;
}
</style>


<style>
#votePanel { display: none !important; }
</style>

<style>
/* === Enlarge both buttons === */
#btnFinishVote,
#btnNewRound {
  font-size: 1.2em !important;
  padding-top: 1.25em !important;
  padding-bottom: 1.25em !important;
  padding-left: 2.5em !important;
  padding-right: 2.5em !important;
}
/* Keep other animation + layout styles */
@keyframes btnVanishOut {
  0%   { transform: scale(1);   opacity: 1;   filter: blur(0); }
  50%  { transform: scale(1.04); opacity: 1; }
  100% { transform: scale(0.85); opacity: 0; filter: blur(1px); }
}
@keyframes btnFadePopIn {
  0%   { transform: scale(0.6);  opacity: 0; filter: blur(0.4px); }
  60%  { transform: scale(1.06); opacity: 1; filter: blur(0); }
  100% { transform: scale(1);    opacity: 1; }
}
.btn-vanish-out { animation: btnVanishOut .32s cubic-bezier(.22,1,.36,1) forwards; }
.finish-hidden { visibility: hidden !important; opacity: 0 !important; pointer-events: none !important; }
.newround-hidden { opacity: 0; visibility: hidden; pointer-events: none; transform: scale(0.9); }
.newround-visible { visibility: visible; animation: btnFadePopIn .38s cubic-bezier(.22,1,.36,1) forwards; }
#screenDiscuss .panel .row { position: relative; }
.btn-center{
  display: inline-flex !important;
  align-items: center !important;
  justify-content: center !important;
  line-height: normal !important;
  white-space: nowrap;
}
</style>


<style>
/* Starter-Bereich: Button mittig zentrieren */
#screenStarter .coverBottom{
  display:flex;
  align-items:center;
  justify-content:center;
  gap: 12px;
}
/* Falls später wieder mehrere Buttons erscheinen, bleiben sie zentriert nebeneinander */
#screenStarter .coverBottom > .btn{
  margin: 0;
}
</style>


<style>
/* Starter 'Weiter'-Button wie 'Weitergeben' in Größe und Stil */
/* === PATCH: Starter-Karte hebt sich an, wenn Weiter-Button sichtbar === */
body.btn-anchored #screenStarter #coverCardStart{
  /* baseline like Deal card */
  margin-bottom: calc(-1 * var(--nextH, 72px) + 8px);
}


body.btn-anchored #screenStarter .underBox {
  padding-bottom: calc( clamp(14px, 5vh, 56px) + var(--nextH, 72px) + 16px ) !important;
}

#screenStarter #btnStarterGo {
  min-width: min(320px, 86vw) !important;
  height: 64px !important;
  font-size: clamp(16px, 4.8vw, 20px) !important;
  border-radius: 16px !important;
  box-shadow: 0 16px 36px rgba(37,99,235,.25) !important;
  font-weight: 800 !important;
}

/* Ruhiges Verhalten beim Klicken wie btnNext */
#screenStarter #btnStarterGo:active {
  transform: translateY(0) !important;
}
</style>


<!-- === PATCH: Starter-Karte wie Deal-Karte (Größe & Look angleichen) === -->
<style>
  /* Gleiche visuelle Größe wie die Deal-Karte */
  #coverCardStart{
    /* responsive Höhe wie bei der Deal-Karte-Wahrnehmung */
    min-height: clamp(300px, 58vh, 520px);
    /* gleiche Überlappung, falls später ein Button/Unterkante reserviert wird */
    margin-bottom: calc(-1 * var(--nextH, 72px) + 8px);
    /* gleiche Kanten/Umrandung */
    border: 1px solid var(--border);
    border-radius: 16px;
    /* gleicher Kartenhintergrund wie die Deal-Karte (coverInner) */
    background: linear-gradient(160deg, var(--card-c1), var(--card-c2));
    /* Deal-Karte hat Schatten via #coverCard entfernt – hier auch deaktivieren */
    box-shadow: none !important;
    position: relative;
    overflow: hidden;
    will-change: transform;
  }

  /* Innerer Bereich wie bei #coverInner: vollflächig, erbt den Hintergrund */
  #coverInnerStart{
    position: absolute;
    inset: 0;
    z-index: 2;
    display: flex;
    align-items: center;
    justify-content: center;
    touch-action: none;
    will-change: transform;
    background: inherit;           /* gleiche Verlaufsfläche wie die Deal-Karte */
    border-radius: inherit;
    overflow: hidden;
  }

  /* Unterer Textblock analog strukturiert (falls Styles fehlen) */
  #coverCardStart .underlay{
    position: absolute;
    inset: 0;
    z-index: 1;
    display: flex;
    align-items: flex-end;
    justify-content: center;
    pointer-events: none;
  }
  #coverCardStart .underBox{
    width: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
    padding-bottom: clamp(14px, 5vh, 56px);
  }
</style>

<style>
/* === Starter: bottom-shrink bounce when snap-back (no reveal) === */
@keyframes starterBottomShrink {
  0%   { transform: scaleY(1); }
  60%  { transform: scaleY(0.94); }
  100% { transform: scaleY(1); }
}
#coverCardStart.bottom-shrink {
  transform-origin: bottom;
  animation: starterBottomShrink 0.28s cubic-bezier(.22,1,.36,1);
}
</style>


<style>
/* === Starter: bottom-edge lift animation & smoothing (like Deal card) === */
#screenStarter #coverCardStart {
  transition: margin-bottom .32s cubic-bezier(.2,.9,.2,1.2),
              transform .28s cubic-bezier(.2,1,.36,1),
              box-shadow .28s ease;
}
#screenStarter .underBox {
  transition: padding-bottom .32s cubic-bezier(.2,.9,.2,1.2);
}
/* Lift/shadow + softer lower corners when the Starter Next button is anchored */
body.btn-anchored #screenStarter #coverCardStart {
  margin-bottom: 8px !important;
  box-shadow: 0 28px 60px rgba(0,0,0,.14);
  border-bottom-left-radius: 22px;
  border-bottom-right-radius: 22px;
}
body.btn-anchored #screenStarter .underBox {
  padding-bottom: calc( clamp(14px, 5vh, 56px) + var(--nextH, 72px) + 16px ) !important;
}
</style>


<style>
/* === Starter-specific anchor class to avoid conflicts === */
body.starter-anchored #screenStarter #coverCardStart {
  margin-bottom: 8px !important;
  box-shadow: 0 28px 60px rgba(0,0,0,.14);
  border-bottom-left-radius: 22px;
  border-bottom-right-radius: 22px;
}
body.starter-anchored #screenStarter .underBox {
  padding-bottom: calc( clamp(14px, 5vh, 56px) + var(--nextH, 72px) + 16px ) !important;
}
</style>


<style>
/* === ScreenDeal: slide in from right when moving from Starter via 'Weiter' === */
@keyframes dealSlideInFromRight {
  from { transform: translateX(100%); opacity: 0; }
  to   { transform: translateX(0);     opacity: 1; }
}
#screenDeal.deal-slide-in {
  animation: dealSlideInFromRight 0.6s cubic-bezier(.25,.8,.25,1) both !important;
  will-change: transform, opacity;
  backface-visibility: hidden;
}
/* If any generic .entering animation is present, prefer our slide */
#screenDeal.deal-slide-in.entering {
  animation: dealSlideInFromRight 0.6s cubic-bezier(.25,.8,.25,1) both !important;
}
</style>


<style>
/* === Align Starter card vertical position with Deal card === */
#screenStarter #coverCardStart {
  margin-bottom: calc(-1 * var(--nextH, 72px) + 8px);
}
</style>


<style>
/* === Force Starter card height to match Deal card (no extra min-height) === */
#coverCardStart{ min-height: 0 !important; }
</style>


<style>
/* === Make Deal (player) card match Starter card baseline & box model === */
#screenDeal #coverCard{
  /* same baseline overlap as Starter */
  margin-bottom: calc(-1 * var(--nextH, 72px) + 8px) !important;
  /* align min-height behavior */
  min-height: 0 !important;
  /* match border & radius like Starter for consistent visual height */
  border: 1px solid var(--border) !important;
  border-radius: 16px !important;
}
/* Ensure anchored state mirrors Starter (margin 8px and added bottom padding) */
body.btn-anchored #screenDeal #coverCard{ margin-bottom: 8px !important; }
body.btn-anchored #screenDeal .underBox{
  padding-bottom: calc( clamp(14px, 5vh, 56px) + var(--nextH, 72px) + 16px ) !important;
}
</style>


<style>
/* === Adjust Deal card baseline to match Starter card (reduce gap by 20px) === */
#screenDeal #coverCard{
  margin-bottom: calc(-1 * var(--nextH, 72px) + 8px - 20px) !important;
}
body.btn-anchored #screenDeal #coverCard{
  margin-bottom: calc(8px - 20px) !important;
}
</style>


<style>
/* === Starter: force fully white interior like player card === */
#coverCardStart,
#coverInnerStart{
  background: #ffffff !important;
  background-image: none !important;
}
/* Ensure any gradient inherited by child layers is neutralized */
#coverCardStart *{
  background-image: none !important;
}
/* Optional: subtle light handle so it stays visible on white */
#screenStarter .handle{
  background: rgba(15,23,42,.10) !important;
}
</style>


<style>
/* === Starter: outer white, inner gradient === */
#coverCardStart{
  background: #ffffff !important;
  background-image: none !important;
}
#coverInnerStart{
  background: linear-gradient(160deg, var(--card-c1), var(--card-c2)) !important;
  background-image: linear-gradient(160deg, var(--card-c1), var(--card-c2)) !important;
}
</style>

<style>
/* === Single-Impostor: super-smooth breathe + halo (ersetzt Shake nur bei 1 Impostor) === */

/* 1) Altes Shake für den Einzel-Fall sicher deaktivieren */
body.one-imp #wordOut.impostor,
body.one-imp #revealOverlay .revealWord.impostor,
body.one-imp #revealOverlay .revealTitle.impostor,
body.one-imp #revealOverlay .revealCard.small.impostor,
body.one-imp #revealArea .revealCard.big .revealWord.impostor {
  animation: none !important;
}

/* 2) Neue, ruhige Animationskombination */
@keyframes impBreathe {
  0%   { transform: scale(0.985); opacity: 0.97; }
  38%  { transform: scale(1.020); opacity: 1; }
  100% { transform: scale(0.985); opacity: 0.97; }
}
@keyframes impHalo {
  0%   { text-shadow: 0 0 0 rgba(239,68,68,0);   filter: drop-shadow(0 0 0 rgba(239,68,68,0)); }
  40%  { text-shadow: 0 0 14px rgba(239,68,68,.55); filter: drop-shadow(0 2px 10px rgba(239,68,68,.28)); }
  100% { text-shadow: 0 0 0 rgba(239,68,68,0);   filter: drop-shadow(0 0 0 rgba(239,68,68,0)); }
}

/* 3) Anwendung – nur wenn body.one-imp gesetzt ist */
body.one-imp #wordOut.impostor,
body.one-imp #revealOverlay .revealWord.impostor,
body.one-imp #revealOverlay .revealTitle.impostor,
body.one-imp #revealOverlay .revealCard.small.impostor,
body.one-imp #revealArea .revealCard.big .revealWord.impostor {
  color: #ef4444;
  will-change: transform, filter;
  backface-visibility: hidden;
  animation:
    impBreathe 1.8s cubic-bezier(.22,1,.36,1) infinite,
    impHalo    2.4s cubic-bezier(.22,1,.36,1) infinite;
}

/* 4) Sanfte Start-Pop-in für die Big-Revealkarte */
body.one-imp #revealOverlay .cardBig.pop-in {
  animation: cardBigPopIn 0.44s cubic-bezier(.2,1,.36,1) both;
}
@keyframes cardBigPopIn {
  0%   { transform: translateY(8px) scale(0.94); opacity: 0; filter: blur(0.4px); }
  60%  { transform: translateY(-2px) scale(1.03); opacity: 1; filter: none; }
  100% { transform: translateY(0)    scale(1); }
}

/* 5) Accessibility: respektiere reduzierte Bewegung */
@media (prefers-reduced-motion: reduce){
  body.one-imp #wordOut.impostor,
  body.one-imp #revealOverlay .revealWord.impostor,
  body.one-imp #revealOverlay .revealTitle.impostor,
  body.one-imp #revealOverlay .revealCard.small.impostor,
  body.one-imp #revealArea .revealCard.big .revealWord.impostor {
    animation: none !important;
    text-shadow: none !important;
    filter: none !important;
  }
}
</style>
<style>
/* === Single-Impostor v2: force smooth override, even if earlier rules set animation === */
@keyframes impBreathe_v2 {
  0%   { transform: scale(0.985); opacity: 0.97; }
  42%  { transform: scale(1.022); opacity: 1; }
  100% { transform: scale(0.985); opacity: 0.97; }
}
@keyframes impHalo_v2 {
  0%   { text-shadow: 0 0 0 rgba(239,68,68,0);   filter: drop-shadow(0 0 0 rgba(239,68,68,0)); }
  45%  { text-shadow: 0 0 16px rgba(239,68,68,.55); filter: drop-shadow(0 2px 12px rgba(239,68,68,.28)); }
  100% { text-shadow: 0 0 0 rgba(239,68,68,0);   filter: drop-shadow(0 0 0 rgba(239,68,68,0)); }
}

/* Force our smooth animation with !important (overrides any prior !important none) */
body.one-imp #wordOut.impostor,
body.one-imp #revealOverlay .revealWord.impostor,
body.one-imp #revealOverlay .revealTitle.impostor,
body.one-imp #revealOverlay .revealCard.small.impostor,
body.one-imp #revealArea .revealCard.big .revealWord.impostor {
  animation: impBreathe_v2 2.1s cubic-bezier(.22,1,.36,1) infinite,
             impHalo_v2    2.8s cubic-bezier(.22,1,.36,1) infinite !important;
  color: #ef4444;
  will-change: transform, filter;
  backface-visibility: hidden;
}

/* Respect reduced motion globally for our v2 */
@media (prefers-reduced-motion: reduce){
  body.one-imp #wordOut.impostor,
  body.one-imp #revealOverlay .revealWord.impostor,
  body.one-imp #revealOverlay .revealTitle.impostor,
  body.one-imp #revealOverlay .revealCard.small.impostor,
  body.one-imp #revealArea .revealCard.big .revealWord.impostor {
    animation: none !important;
    text-shadow: none !important;
    filter: none !important;
  }
}
</style>
<style>
/* === FIX: Smooth animation specifically when pressing "Auflösen" (SINGLE impostor reveal) === */
/* Kill any previous animations for the big overlay card and replace with a very gentle slide+breathe */
#revealOverlay.single .cardBig {
  /* cancel old keyframes from earlier styles */
  animation: none !important;
  will-change: transform, opacity, filter;
  backface-visibility: hidden;
}
@keyframes revealCardSmoothIn {
  0%   { transform: translateY(10px) scale(0.96); opacity: 0; filter: blur(0.6px); }
  55%  { transform: translateY(-2px) scale(1.01); opacity: 1; filter: none; }
  100% { transform: translateY(0)    scale(1.00); }
}
#revealOverlay.single .cardBig {
  animation: revealCardSmoothIn 0.55s cubic-bezier(.22,1,.36,1) both !important;
}

/* Soft, subtle text glow for the impostor name in the overlay */
@keyframes overlayImpHalo {
  0%   { text-shadow: 0 0 0 rgba(239,68,68,0); filter: drop-shadow(0 0 0 rgba(239,68,68,0)); }
  45%  { text-shadow: 0 0 14px rgba(239,68,68,.55); filter: drop-shadow(0 2px 10px rgba(239,68,68,.28)); }
  100% { text-shadow: 0 0 0 rgba(239,68,68,0); filter: drop-shadow(0 0 0 rgba(239,68,68,0)); }
}
#revealOverlay.single .revealTitle.impostor,
#revealOverlay.single .revealWord.impostor {
  animation: overlayImpHalo 2.6s cubic-bezier(.22,1,.36,1) infinite !important;
  color: #ef4444;
}

/* Respect reduced motion */
@media (prefers-reduced-motion: reduce){
  #revealOverlay.single .cardBig { animation: none !important; filter: none !important; }
  #revealOverlay.single .revealTitle.impostor,
  #revealOverlay.single .revealWord.impostor { animation: none !important; text-shadow: none !important; filter: none !important; }
}
</style>

<link rel="manifest" href="manifest.json">
<meta name="theme-color" content=#ffffff">
<script>
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => navigator.serviceWorker.register('sw.js'));
}
</script>
</head>
<body>


<canvas id="confettiCanvas"></canvas>
<div class="stage">
<header>
<h1>IMPOSTER · Vollbild</h1>
<span class="badge" id="roundBadge">Runde 1</span>
</header>
<div class="screens">
<!-- START -->
<section class="screen active" id="screenStart">
<div class="panel">
<p class="muted" style="margin:0">Wählt 3–20 Spieler &amp; gebt die Namen ein.</p>
<div class="row">
<button class="btn btn-lite btn-round" id="minusBtn">−</button>
<div class="num" id="playerNum">5</div>
<button class="btn btn-lite btn-round" id="plusBtn">+</button>
</div>
</div>
<div class="panel" id="namesPanel">
<div class="row" id="namesWrap" style="justify-content:flex-start; gap:8px; flex-wrap:wrap"></div>
</div>
<div class="panel">
<div class="row">
<button class="btn btn-blue" id="btnStart">Spiel starten</button>
<button class="btn btn-green" id="btnShuffle">Spielmodus: Klassisch</button>
</div>
</div>
</section>
<!-- MODE SELECT -->
<section class="screen" id="screenMode" style="display:none;  background:rgba(255,255,255,0.95);  border-radius:18px"><div class="modeWrap"><div class="modeHeader"><h2>Spielmodus wählen</h2><button aria-label="Schließen" class="modeClose" id="btnCloseMode">✕</button></div>

<div class="modeGrid">

    <!-- PATCH: Blind Impostor Mode Card -->
    <div class="modeCard" data-mode="Blind Impostor">
      <span class="modeTag">Blind Impostor</span>
      <p class="modeDesc">Der Impostor ist blind – muss ohne Sicht arbeiten.</p>
    </div>
<div class="modeCard" data-mode="Klassisch" id="cardClassic"><span class="modeTag">Klassisch</span><div class="modeTitle">Klassisch
<div class="modeCard" data-mode="Verdeckter Impostor">
  <div class="modeTag">Neu</div>
  <h3 class="modeTitle">Verdeckter Impostor</h3>
  <p class="modeDesc">
    Es gibt Impostor – aber sie sehen beim Austeilen das ganz normale Wort
    und wissen nicht, dass sie Impostor sind. Auflösung erst am Ende.
  </p>
</div>
</div><p class="modeDesc">Standard-Regeln: Der Impostor sieht nur einen kurzen, indirekten Hinweis. Alle anderen sehen das echte Wort.</p></div><div class="modeCard" data-mode="Ohne Hinweis" id="cardNoHint"><span class="modeTag">Ohne Hinweis</span><div class="modeTitle">Ohne Hinweis</div><p class="modeDesc">Für Profis: Der Impostor bekommt überhaupt keinen Hinweis.</p></div></div>
    <!-- === Impostor-Anzahl Panel (merged) === -->
    <div class="panel" id="impostorPanel" style="margin-top:16px;">
      <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;">
        <strong>Impostors</strong>
        <span class="pill">
          Aktuell: <b id="impostorCount">1</b> / <span id="impostorMaxLabel">4</span>
        </span>
      </div>
      <input id="impostorSlider" type="range" min="1" max="4" value="1" style="width:100%;">
      <p class="muted" style="margin:6px 0 0;">Mindestens <b>1</b> Nicht-Impostor bleibt immer übrig.</p>
    </div>
    <!-- === Ende Impostor-Anzahl Panel === -->
</div></section>

<!-- STARTER (Zwischenscreen als Karte) -->
<section class="screen" id="screenStarter" style="display:none;">
  <div class="coverWrap">
    <div class="coverTop">
      <span class="pill">Wer beginnt?</span>
      <button class="btn btn-red" id="btnStarterCancel">Abbrechen</button>
    </div>

    <div class="coverCard" id="coverCardStart">
      <div class="underlay">
        <div class="underBox">
          <p class="word" id="starterWordOut">—</p>
          <p class="sub" id="starterSubOut">Zieh die Karte kurz nach oben, um den/die Starter:in zu sehen.</p>
        </div>
      </div>
      <div class="coverInner" id="coverInnerStart">
        <div class="coverNameBig" id="starterNameBig">STARTER</div>
        
      </div>
    </div>

    <div class="coverBottom">
      
      <button class="btn btn-blue" id="btnStarterGo" style="visibility:hidden; opacity:0;">Weiter</button>
    </div>
  </div>
</section>

<!-- DEAL -->
<section class="screen" id="screenDeal">
<div class="coverWrap">
<div class="coverTop">
<span class="pill">Spieler <b id="dealIndex">1</b> / <span id="dealTotal">5</span></span>
<button class="btn btn-red" id="btnReset">Abbrechen</button>
</div>
<div class="coverCard" id="coverCard">
<div class="underlay">
<div class="underBox">
<p class="word" id="wordOut">—</p>
<p class="sub" id="subOut">Zieh die Karte kurz nach oben (für Wort/Impostor). Danach <b>auf „Weitergeben“ tippen</b>.</p>
</div>
</div>
<div class="coverInner" id="coverInner">
<div class="coverNameBig" id="coverNameBig">SPIELER 1</div>
<div class="handle"></div>
<div class="coverHint" id="coverHint">Nach oben ziehen</div>
</div>
</div>
<div class="row" id="nextRow" style="margin-top:12px">
<button class="btn btn-blue btn-next-big" id="btnNext">Weitergeben →</button>
</div>
</div>
</section>
<!-- DISCUSS -->
<section class="screen" id="screenDiscuss">
<div class="panel" style="text-align:center">
<div class="row" style="margin-top:0">
<button class="btn btn-blue" disabled="" id="btnFinishVote">Auflösen</button>
<button class="btn btn-green" id="btnNewRound" style="display:none">Neue Runde</button>
</div>
<div class="votePanel" id="votePanel">
<div class="voteTop">
<div class="left">
<span class="remBadge">Verbleibende Stimmen: <b id="votesLeft">0</b></span>
</div>
<div class="right">
<button class="btn btn-lite" id="toggleCompact">Kompakt</button>
</div>
</div>
<div id="voteScroll">
<div id="voteList"></div>
</div>
<div class="muted" id="voteResult" style="display:none; margin-top:4px"></div>
</div>
<div class="sub" id="revealBox" style="margin-top:6px; display:none">
            Gesuchtes Wort: <b id="revealWord">—</b>
</div>
</div>

<div id="revealOverlay"></div>
</section>
</div>
</div>
<script>
function triggerWordPulseNormal() {
  const w = document.getElementById('wordOut');
  if (!w) return;
  const underlay = w.closest('.underlay');
  const isHidden = () => {
    if (!underlay) return document.body.classList.contains('underlay-hidden');
    const style = window.getComputedStyle(underlay);
    return document.body.classList.contains('underlay-hidden') ||
           style.visibility === 'hidden' ||
           parseFloat(style.opacity || '1') < 0.05;
  };
  const run = () => {
    w.classList.remove('pulse-normal');
    void w.offsetWidth; // reflow to restart
    w.classList.add('pulse-normal');
    w.addEventListener('animationend', () => w.classList.remove('pulse-normal'), { once: true });
  };
  if (isHidden()) {
    let tries = 0;
    const t = setInterval(() => {
      tries++;
      if (!isHidden() || tries > 15) { // fallback: fire anyway after ~900ms
        clearInterval(t);
        run();
      }
    }, 60);
  } else {
    run();
  }
}



// ----------------- Daten -----------------
const WORDS=[
  {word:"Pfannkuchen",hint:"Morgens: Rundes Ritual, das knusprig flach in Metall geboren wird, oft mit süßer Tarnung."},
  {word:"Detektiv",hint:"Folgt Fußspuren, die niemand sieht, und stellt Fragen, die niemand hören will."},
  {word:"Strand",hint:"Ein Ort, an dem die Zeit im Takt von Atemzügen einer riesigen, salzigen Lunge geht."},
  {word:"Schluckauf",hint:"Ein kleines Aufbäumen im Inneren, das jede Ruhe in Klammern setzt."},
  {word:"Flugzeug",hint:"Ein Metallvogel, der nur auf Straßen landet, die keine Kurven kennen."},
  {word:"Pizza",hint:"Ein Kreis, der in Dreiecke zerfällt und dadurch Freunde zusammenfügt."},
  {word:"Telefon",hint:"Ein Rechteck, das Stimmen konserviert und Entfernung in Sekunden schrumpfen lässt."},
  {word:"Zähneputzen",hint:"Ein Schaumritual gegen die Erinnerung an Zucker."},
  {word:"Laptop",hint:"Eine Klappe, die aufgeht, wenn Arbeit aus dem Schoß fällt."},
  {word:"Schwimmen",hint:"Wenn die Schwerkraft Urlaub nimmt und Atem Pausen diktiert."},
  {word:"Verstecken",hint:"Ein Spiel, bei dem Anwesenheit gewinnt, indem sie so tut, als wäre sie Abwesenheit."},
  {word:"Regenschirm",hint:"Privates Dach zum Mitnehmen, entfaltet gegen zerfallenden Himmel."},
  {word:"Bibliothek",hint:"Ein Wald aus Rücken, in dem Bäume aus Papier flüstern."},
  {word:"Rakete",hint:"Eine Kerze, die nach oben brennt, bis die Nacht zu dünn wird."},
  {word:"Kompass",hint:"Eine Nadel, die einer unsichtbaren Architektur gehorcht."},
  {word:"Schneemann",hint:"Eine vergängliche Skulptur, die den Frühling fürchtet."},
  {word:"Kopfhörer",hint:"Zwei kleine Vorhänge, die die Welt leiser machen."},
  {word:"Taschenlampe",hint:"Eine Handvoll Tag, gezielt in die Nacht gegossen."},
  {word:"Koffein",hint:"Flüssige Absicht, damit Gedanken schneller werden als Gähnen."},
  {word:"Wolkenkratzer",hint:"Wenn Gebäude versuchen, den Himmel zu berühren, ohne zu stolpern."},
  {word:"Bäckerei",hint:"Ort, an dem Zeit und Wärme Teig Geschichten erzählen lassen."},
  {word:"Zebra",hint:"Ein Pferd im Gefängnisstreifen-Look, das sich an Straßenrändern beliebt macht."},
  {word:"Mikroskop",hint:"Ein Portal, das Unwichtiges groß und plötzlich wichtig macht."},
  {word:"Seife",hint:"Ein Rechteck, das Erinnerungen an Hände verschwinden lässt."},
  {word:"Brücke",hint:"Ein Ja über Wasser oder Leere."},
  {word:"Schlüssel",hint:"Kleines Metall, das Türen überzeugt, ihre Meinung zu ändern."},
  {word:"Kamin",hint:"Ein Fenster, das Feuer zeigt, ohne das Haus zu verlieren."},
  {word:"Garten",hint:"Ein Stück Erde mit Geduld."},
  {word:"Pendeluhr",hint:"Zeit, die mit den Schultern zuckt."},
  {word:"Kaktus",hint:"Eine Pflanze, die Nähe mit Nadeln beantwortet."},
  {word:"Bumerang",hint:"Ein Wurf, der die Idee von Weggehen missversteht."},
  {word:"U-Boot",hint:"Ein Haus, das atmet, ohne Luft zu sehen."},
  {word:"Sanduhr",hint:"Zwei Gläser, die Geduld zählen."},
  {word:"Kopfkissen",hint:"Eine Wolke, die nicht fliegt."},
  {word:"Schach",hint:"Ein Krieg, der höflich im Quadrat bleibt."},
  {word:"Teleskop",hint:"Ein Rohr, das Sterne näher bittet."},
  {word:"Eisberg",hint:"Eine Wahrheit, die zu 90% verschwiegen bleibt."},
  {word:"Tornado",hint:"Ein Tänzer, der Häuser als Partner wählt."},
  {word:"Kranich (Vogel)",hint:"Ein Spaziergänger auf Stelzen, der Gewässer zu Laufstegen macht."},
  {word:"Feuerwerk",hint:"Kurzzeitige Blumen, die in die Nacht gepflanzt werden."},
  {word:"Schneeflocke",hint:"Ein Gedanke des Winters mit sechs Armen."},
  {word:"Metronom",hint:"Ein Takt, der mit Nein und Ja zählt."},
  {word:"Puzzle",hint:"Ein Bild, das sich weigert, ohne Mitwirkung zu existieren."},
  {word:"Thermometer",hint:"Ein Glas, das fühlt."},
  {word:"Stethoskop",hint:"Zuhören als Beruf, verstärkt durch Gummi."},
  {word:"Parfum",hint:"Erinnerung in Luftform."},
  {word:"Seilbahn",hint:"Ein Faden, der Städte zusammen näht."},
  {word:"Gewächshaus",hint:"Ein Zimmer, in dem Wetter höflich ist."},
  {word:"Briefmarke",hint:"Ein kleiner Reisender, der klebt, um wegzukommen."},
  {word:"Laterne",hint:"Ein Gefäß für gezähmtes Leuchten."},
  {word:"Schornstein",hint:"Ein Hals, der Rauch ausspuckt, damit Häuser atmen."},
  {word:"Tintenfisch",hint:"Ein Maler, der Wasser als Atelier nutzt."},
  {word:"Origami",hint:"Papier, das mit Falten Bedeutung bekommt."},
  {word:"Pendlerzug",hint:"Eine Schlange aus Stahl, die Pünktlichkeit frisst."},
  {word:"Kreide",hint:"Stein, der kurzfristig schreibt."},
  {word:"Taschenmesser",hint:"Ein Werkzeug, das gern Geheimnisse in sich trägt."},
  {word:"Gewitter",hint:"Der Himmel, der seine Meinung laut ändert."},
  {word:"Fahrrad",hint:"Zwei Kreise, die eine Entscheidung tragen."},
  {word:"Gabelstapler",hint:"Ein kleiner Titan, der Paletten tanzen lässt."},
  {word:"Mosaik",hint:"Viele kleine Nein, die zusammen ein Ja ergeben."},
  {word:"Kaleidoskop",hint:"Ein Auge, das Vielfalt feiert, indem es dreht."},
  {word:"Teezeremonie",hint:"Langsamkeit in Tassenform."}
];

// --- Subtle one-word hint mapping (indirect) ---
const hintMap = {
  "Pfannkuchen": "Frühstück",
  "Detektiv": "Spur",
  "Strand": "Küste",
  "Schluckauf": "Zucken",
  "Flugzeug": "Startbahn",
  "Pizza": "Ofen",
  "Telefon": "Anruf",
  "Zähneputzen": "Hygiene",
  "Laptop": "Tastatur",
  "Schwimmen": "Wasser",
  "Verstecken": "Suche",
  "Regenschirm": "Tropfen",
  "Bibliothek": "Regal",
  "Rakete": "Schub",
  "Kompass": "Norden",
  "Schneemann": "Winter",
  "Kopfhörer": "Stille",
  "Taschenlampe": "Strahl",
  "Koffein": "Wach",
  "Wolkenkratzer": "Skyline",
  "Bäckerei": "Teig",
  "Zebra": "Streifen",
  "Mikroskop": "Linse",
  "Seife": "Schaum",
  "Brücke": "Übergang",
  "Schlüssel": "Zugang",
  "Kamin": "Funken",
  "Garten": "Beet",
  "Pendeluhr": "Takt",
  "Kaktus": "Wüste",
  "Bumerang": "Rückkehr",
  "U-Boot": "Tiefe",
  "Sanduhr": "Körner",
  "Kopfkissen": "Traum",
  "Schach": "Zug",
  "Teleskop": "Sterne",
  "Eisberg": "Tiefe",
  "Tornado": "Wirbel",
  "Kranich (Vogel)": "Stelzen",
  "Feuerwerk": "Himmel",
  "Schneeflocke": "Muster",
  "Metronom": "Tempo",
  "Puzzle": "Teile",
  "Thermometer": "Grad",
  "Stethoskop": "Puls",
  "Parfum": "Duft",
  "Seilbahn": "Gondel",
  "Gewächshaus": "Glas",
  "Briefmarke": "Porto",
  "Laterne": "Leuchte",
  "Schornstein": "Rauch",
  "Tintenfisch": "Tentakel",
  "Origami": "Falten",
  "Pendlerzug": "Gleis",
  "Kreide": "Tafel",
  "Taschenmesser": "Klinge",
  "Gewitter": "Donner",
  "Fahrrad": "Pedale",
  "Gabelstapler": "Palette",
  "Mosaik": "Steinchen",
  "Kaleidoskop": "Spiegel",
  "Teezeremonie": "Ritual"
};

const CARD_COLORS=[['#6366f1','#22d3ee'], ['#f59e0b','#ef4444'], ['#06b6d4','#10b981'], ['#8b5cf6','#ec4899'], ['#3b82f6','#a855f7'],
  ['#eab308','#84cc16'], ['#f472b6','#fb7185'], ['#14b8a6','#22c55e'], ['#60a5fa','#0ea5e9'], ['#f97316','#f43f5e'],
  ['#22d3ee','#38bdf8'], ['#34d399','#84cc16'], ['#f43f5e','#a855f7'], ['#10b981','#06b6d4'], ['#ef4444','#f59e0b'],
  ['#ec4899','#8b5cf6'], ['#a3e635','#22c55e'], ['#0ea5e9','#3b82f6'], ['#fde047','#fb7185'], ['#84cc16','#22d3ee']];

let state={ totalImpostors:1,  gameMode:'Klassisch', round:1,totalPlayers:5,currentIndex:0,impostorIndex:0,current:{word:"",hint:""}, names:[],
           revealedThisTurn:false, votes:[], votesLeft:0, voteLocked:false };

const $=s=>document.querySelector(s);
const rand=m=>Math.floor(Math.random()*m);
const badge=()=>$('#roundBadge').textContent=`Runde ${state.round}`;
function pickWord(){ return WORDS[rand(WORDS.length)]; }
function setCardColor(i){
  const [c1,c2]=CARD_COLORS[i % CARD_COLORS.length];
  document.documentElement.style.setProperty('--card-c1', c1);
  document.documentElement.style.setProperty('--card-c2', c2);
  const fg=computeContrastingColor(c1,c2);
  document.documentElement.style.setProperty('--card-fg', fg);
}
function setPlayerName(i){ $('#coverNameBig').textContent=(state.names[i]||`Spieler ${i+1}`).toUpperCase(); }
function hexToRgb(h){h=h.replace('#',''); if(h.length===3) h=[h[0]+h[0],h[1]+h[1],h[2]+h[2]].join(''); const num=parseInt(h,16); return [(num>>16)&255,(num>>8)&255,num&255];}
function luminance(rgb){const a=rgb.map(v=>{v/=255; return v<=0.03928? v/12.92 : Math.pow((v+0.055)/1.055,2.4);}); return 0.2126*a[0]+0.7152*a[1]+0.0722*a[2];}
function computeContrastingColor(h1,h2){ const l=(luminance(hexToRgb(h1))+luminance(hexToRgb(h2)))/2; return l<0.55? '#ffffff' : '#0f172a'; }


function pickImpostor(){
  try{
    // Ensure totalPlayers is a number
    const players = Number(state.totalPlayers) || 1;
    state.impostorIndex = Math.floor(Math.random() * players);
  }catch(_){}
}



document.addEventListener('click',e=>{
  const btn=e.target.closest('.btn'); if(!btn) return;
  const rect=btn.getBoundingClientRect();
  const x=(e.clientX||rect.width/2)-rect.left;
  const y=(e.clientY||rect.height/2)-rect.top;
  const r=document.createElement('span'); r.className='ripple'; r.style.left=x+'px'; r.style.top=y+'px';
  btn.appendChild(r); r.addEventListener('animationend',()=>r.remove());
},{passive:true});

function buildNameInputs(){
  const wrap = $('#namesWrap');
  const oldCount = wrap.children.length; // how many inputs existed before rebuild
  wrap.innerHTML = '';

  for(let i=0; i<state.totalPlayers; i++){
    const inp = document.createElement('input');
    inp.type='text';
    inp.className='name';
    inp.placeholder = `Spieler ${i+1}`;
    inp.value = state.names[i] || `Spieler ${i+1}`;
    inp.addEventListener('input', ()=>{
      state.names[i] = inp.value.trim() || `Spieler ${i+1}`;
    });

    // Animate only the NEWLY ADDED input when count increased (plus was pressed)
    if (state.totalPlayers > oldCount && i === state.totalPlayers - 1){
      inp.classList.add('pop-in');
      inp.addEventListener('animationend', ()=> inp.classList.remove('pop-in'), { once:true });
    }

    wrap.appendChild(inp);
  }
}
$('#plusBtn').addEventListener('click',()=>{
  state.totalPlayers=Math.min(20,state.totalPlayers+1);
  $('#playerNum').textContent=state.totalPlayers;
  $('#dealTotal').textContent=state.totalPlayers;
  buildNameInputs();

  

  try{ updateImpostorSliderLimits(); }catch(_){}
});

$('#minusBtn').addEventListener('click',()=>{
  if(state.totalPlayers <= 3){
    state.totalPlayers = 3;
    return; // nothing to remove
  }
  const wrap = $('#namesWrap');
  const last = wrap && wrap.lastElementChild;
  if(last){
    // Play pop-out animation, then actually remove & rebuild
    last.classList.add('pop-out');
    last.addEventListener('animationend', ()=>{
      state.totalPlayers = Math.max(3, state.totalPlayers - 1);
      $('#playerNum').textContent = state.totalPlayers;
      $('#dealTotal').textContent = state.totalPlayers;
      state.names.length = Math.min(state.names.length, state.totalPlayers);
      buildNameInputs();
    }, { once:true });


const impostorSlider = document.getElementById('impostorSlider');
const impostorCountEl = document.getElementById('impostorCount');
const impostorMaxLabel = document.getElementById('impostorMaxLabel');

function updateImpostorSliderLimits() {
  const el = document.getElementById('impostorSlider');
  const countEl = document.getElementById('impostorCount');
  const maxLbl = document.getElementById('impostorMaxLabel');
  if (!el) return;
  const players = Number(state?.totalPlayers || document.getElementById('playerNum')?.textContent || 3) || 3;
  const maxImpostors = Math.max(1, players - 1);
  el.max = String(maxImpostors);
  el.setAttribute('max', String(maxImpostors));
  el.min = '1';
  el.setAttribute('min', '1');
  let v = parseInt(el.value, 10) || 1;
  if (v > maxImpostors) v = maxImpostors;
  if (v < 1) v = 1;
  el.value = String(v);
  if (countEl) countEl.textContent = el.value;
  if (maxLbl) maxLbl.textContent = el.max;
  state.totalImpostors = v;
}

document.addEventListener('DOMContentLoaded', updateImpostorSliderLimits);


  }else{
    // Fallback
    state.totalPlayers = Math.max(3, state.totalPlayers - 1);
    $('#playerNum').textContent = state.totalPlayers;
    $('#dealTotal').textContent = state.totalPlayers;
    state.names.length = Math.min(state.names.length, state.totalPlayers);
    buildNameInputs();
  }
});


$('#btnShuffle').addEventListener('click',()=>{
  
  try{ updateImpostorSliderLimits(); }catch(_){}
show('screenMode');
});

$('#btnStart').addEventListener('click',()=>{
  
  pickImpostor();
state.names=[...$('#namesWrap').querySelectorAll('input')].map((el,i)=> el.value.trim()||`Spieler ${i+1}`);
  if(state.names.length<state.totalPlayers){
    for(let i=state.names.length;i<state.totalPlayers;i++) state.names.push(`Spieler ${i+1}`);
  }
  state.current=pickWord();
  state.impostorIndices = pickImpostorIndices(state.totalPlayers, state.totalImpostors);
  state.impostorIndex = state.impostorIndices[0] ?? 0;
  state.currentIndex=0;
  $('#dealTotal').textContent=state.totalPlayers;
  $('#dealIndex').textContent='1';
  setPlayerName(0);
  setCardColor(0);
  setUnderlayContent();
  state.revealedThisTurn=false;
  state.votes = Array(state.totalPlayers).fill(0);
  state.votesLeft = state.totalPlayers;
  state.voteLocked = false;
  updateVotesLeft();
  $('#voteResult').style.display='none';
  $('#revealBox').style.display='none';
  $('#btnNewRound').style.display='none';
  $('\#btnFinishVote').disabled = true;
  const _fv = document.getElementById('btnFinishVote'); if(_fv){ _fv.textContent = 'Auflösen'; }
  const btnNext = $('#btnNext'); btnNext.style.display='none'; btnNext.classList.remove('pop');
  show('screenStarter'); badge();
  try{ var _c=document.getElementById('coverCard'); if(_c){ _c.style.transform=''; } }catch(_){}
});

/* Pull-to-reveal */
const inner=$('#coverInner');
const coverCardEl = document.getElementById('coverCard');

let dragging=false, startY=0, currentY=0, pull=0;
const THRESH=30; const MAXPULL=window.innerHeight*0.7;


function onPointerDown(e){
  dragging = true;
  startY = (e.touches ? e.touches[0].clientY : e.clientY);
  currentY = startY;
  inner.style.transition = 'none';
}
function onPointerMove(e){
  if(!dragging) return;
  currentY = (e.touches ? e.touches[0].clientY : e.clientY);
  pull = Math.min(0, currentY - startY);
  pull = Math.max(pull, -MAXPULL);
  inner.style.transform = `translateY(${pull}px)`;
  if(pull < 0){
    coverCardEl && coverCardEl.classList.add('stretching');
  } else {
    coverCardEl && coverCardEl.classList.remove('stretching');
  }

  if(pull < -THRESH && !state.revealedThisTurn){
    state.revealedThisTurn = true;
    try{ navigator.vibrate && navigator.vibrate(10) }catch(_){} 
  }
}
function onPointerUp(){
  if(!dragging) return;
  dragging = false;
  inner.style.transition = 'transform .45s cubic-bezier(.22,1,.36,1)';
  inner.style.transform = 'translateY(0)';
  pull = 0;
  coverCardEl && coverCardEl.classList.remove('stretching');
}
inner.addEventListener('mousedown', onPointerDown);
inner.addEventListener('touchstart', onPointerDown, { passive:true });
window.addEventListener('mousemove', onPointerMove, { passive:true });
window.addEventListener('touchmove', onPointerMove, { passive:true });
window.addEventListener('mouseup', onPointerUp, { passive:true });
window.addEventListener('touchend', onPointerUp, { passive:true });
inner.addEventListener('mousedown',onPointerDown);
inner.addEventListener('touchstart',onPointerDown,{passive:true});
window.addEventListener('mousemove',onPointerMove,{passive:true});
window.addEventListener('touchmove',onPointerMove,{passive:true});
window.addEventListener('mouseup',onPointerUp,{passive:true});
window.addEventListener('touchend',onPointerUp,{passive:true});

function setUnderlayContent(){
  clearImpostorEffects();
  const isImp = isImpostor(state.currentIndex);
  const w = document.getElementById('wordOut');
  const s = document.getElementById('subOut');

  if (!w || !s) return;

  if (isImp && impostorEffectsAllowed()) {
    w.textContent = 'IMPOSTOR';
    w.classList.add('impostor');
    const baseWord = (state.current && state.current.word) ? state.current.word : '';
    const mapped = (typeof hintMap !== 'undefined' && hintMap[baseWord]) ? hintMap[baseWord] : '';
    const fallback = (state.current && typeof state.current.hint === 'string') ? state.current.hint.trim().split(/\s+/)[0] : '';
    const tip = (mapped && String(mapped).split(/\s+/)[0]) || fallback;
    s.textContent = (state.gameMode === 'Ohne Hinweis') ? '' : ('Hinweis: ' + tip);
    try { startImpostorParticles(); } catch (e) { /* no-op */ }
  } else {
    w.textContent = state.current && state.current.word ? state.current.word : '';
    w.classList.remove('impostor');
    s.textContent = '';
    try {
    // Blind Impostor: echtes anderes Zufallswort für den Impostor
    try {
      if (state && state.gameMode === 'Blind Impostor' && isImp && Array.isArray(WORDS) && WORDS.length > 1) {
        let base = (state.current && state.current.word) ? state.current.word : '';
        let pool = WORDS.filter(o => o && typeof o.word === 'string' && o.word !== base);
        if (pool.length > 0) {
          let alt = pool[Math.floor(Math.random() * pool.length)];
          if (alt && alt.word) { w.textContent = alt.word; }
        }
      }
    } catch(e) { /* no-op */ }
 triggerWordPulse(); 
    try { triggerWordPulseNormal(); } catch(e) {}} catch (e) { /* no-op */ }
  }
}

/* === Word pulse + impostor particles === */


// Small radial particle burst when impostor is revealed
function startImpostorParticles() {
  const word = document.getElementById('wordOut');
  if (!word) return;
  const underlay = word.closest('.underlay') || document.body;

  // canvas sized to underlay
  const canvas = document.createElement('canvas');
  canvas.width = Math.max(underlay.clientWidth, 1);
  canvas.height = Math.max(underlay.clientHeight, 1);
  canvas.className = 'imp-particles';
  underlay.appendChild(canvas);

  const ctx = canvas.getContext('2d');
  // center from word position relative to underlay
  const rectU = underlay.getBoundingClientRect();
  const rectW = word.getBoundingClientRect();
  const cx = (rectW.left - rectU.left) + rectW.width / 2;
  const cy = (rectW.top - rectU.top) + rectW.height / 2;

  const N = 120;
  const parts = [];
  for (let i = 0; i < N; i++) {
    const ang = Math.random() * Math.PI * 2;
    const speed = 2 + Math.random() * 4;
    parts.push({
      x: cx, y: cy,
      vx: Math.cos(ang) * speed,
      vy: Math.sin(ang) * speed - (Math.random()*0.5),
      r: 1.5 + Math.random()*2.5,
      life: 60 + Math.floor(Math.random()*20),
      color: i % 3 === 0 ? '#ff4444' : (i % 3 === 1 ? '#ffbb33' : '#ffffff')
    });
  }

  (function tick() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    let alive = 0;
    for (const p of parts) {
      if (p.life <= 0) continue;
      // physics
      p.x += p.vx;
      p.y += p.vy;
      p.vx *= 0.985;
      p.vy = p.vy * 0.985 + 0.06; // a hint of gravity
      p.life--;

      const alpha = Math.max(p.life / 80, 0);
      ctx.globalAlpha = alpha;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
      ctx.fill();

      if (p.life > 0) alive++;
    }
    if (alive > 0) {
      requestAnimationFrame(tick);
    } else {
      canvas.remove();
    }
  })();
}

/* --------- KEINE Karten-Animation: sofortiger Wechsel --------- */
function animateSlideToNext(updateFn){
  const card = document.getElementById('coverCard');
  const underlay = card.querySelector('.underlay');
  const inner = card.querySelector('.coverInner');
  if(!card || !underlay || !inner){ updateFn(); return; }

  // Floating-Layer innerhalb der Karte (clipped), um Header/Start nicht zu berühren
  const layer = document.createElement('div');
  layer.style.position = 'absolute';
  layer.style.inset = '0';
  layer.style.overflow = 'hidden';
  layer.style.pointerEvents = 'none';
  layer.style.zIndex = '5';

  const nextUnderlay = underlay.cloneNode(true);
  const nextInner = inner.cloneNode(true);
  [nextUnderlay, nextInner].forEach(L => L.querySelectorAll('[id]').forEach(el => el.removeAttribute('id')));

  // Nächsten Index nur zur Anzeige (Inhalte) berechnen – State wird erst mit updateFn geändert
  const tmpIdx = (state.currentIndex + 1) % state.totalPlayers;
  const isImpNext = isImpostor(tmpIdx);

  const nameEl = nextInner.querySelector('.coverNameBig');
  if(nameEl){ nameEl.textContent = (state.names[tmpIdx] || `Spieler ${tmpIdx+1}`).toUpperCase(); }
  try {
    const [c1,c2] = CARD_COLORS[tmpIdx % CARD_COLORS.length];
    nextInner.style.background = `linear-gradient(160deg, ${c1}, ${c2})`;
  } catch(e){}

  const wEl = nextUnderlay.querySelector('.word');
  const sEl = nextUnderlay.querySelector('.sub');
  if(wEl && sEl){
    if(isImpNext){
      wEl.textContent = 'IMPOSTOR';
      wEl.classList.add('impostor');
      sEl.textContent = 'Hinweis: ' + state.current.hint;
    }else{
      wEl.textContent = state.current.word;
      wEl.classList.remove('impostor');
      sEl.textContent = '';
    }
  }

  layer.appendChild(nextUnderlay);
  layer.appendChild(nextInner);
  card.appendChild(layer);

  // Aktuelle Schicht ausfaden, neue von unten rein (kleiner Bounce)
  const fadeDur = 180;
  inner.animate([{opacity:1},{opacity:0}], {duration:fadeDur, easing:'ease-out'});
  underlay.animate([{opacity:1},{opacity:0}], {duration:fadeDur, easing:'ease-out'});

  layer.style.transform = 'translateY(115%)';
  const drop = layer.animate(
    [
      { transform: 'translateY(115%)' },
      { transform: 'translateY(-10px)', offset: 0.86 },
      { transform: 'translateY(3px)',  offset: 0.94 },
      { transform: 'translateY(0)' }
    ],
    { duration: 700, easing: 'cubic-bezier(.22,1,.36,1)' }
  );

  drop.addEventListener('finish', ()=>{
    layer.remove();
    try{ updateFn(); }catch(_){}
  });
}

/* Weitergeben */
$('#btnNext').addEventListener('click',()=>{
  const isLast = (state.dealtCount >= state.totalPlayers);

  // Wenn Karte noch nicht aufgedeckt ist, wie gehabt abbrechen – außer beim allerletzten
  if(!state.revealedThisTurn && !isLast) return;
  if(!state.revealedThisTurn && isLast){
    try { setUnderlayContent(); } catch(_){}
    try { document.body.classList.remove('underlay-hidden'); } catch(_){}
    state.revealedThisTurn = true;
  }

  if(state.dealtCount < state.totalPlayers){
    const nextIndex = (state.currentIndex + 1) % state.totalPlayers; // Wrap!
    animateSlideToNext(()=>{
      state.currentIndex = nextIndex;
      state.dealtCount++; // mitzählen
      $('#dealIndex').textContent = String(state.currentIndex + 1);
      setPlayerName(state.currentIndex);
      setCardColor(state.currentIndex);
      setUnderlayContent();
      state.revealedThisTurn = false;
    });
  }else{
    $('#revealWord').textContent = state.current.word;
    buildVoteList();
    state.revealMode = true;
    state.revealedImpostors = [];
    state.revealsLeft = (state.impostorIndices && state.impostorIndices.length ? state.impostorIndices.length : 1);
    show('screenDiscuss');
    if (typeof resetVotingRound === 'function') resetVotingRound();
    (function(){
      const fvBtn = document.getElementById('btnFinishVote');
      if (fvBtn){ fvBtn.textContent = 'Auflösen (' + state.revealsLeft + ' übrig)'; }
    })();
  }
});

/* Voting */
document.getElementById('btnFinishVote').addEventListener('click',()=>{ revealNextImpostor(); });
$('#btnNewRound').addEventListener('click',()=>{ 
  pickImpostor();
state.round++; badge(); show('screenStart'); });
$('#toggleCompact').addEventListener('click',()=>{
  document.getElementById('voteScroll').classList.toggle('compact');
});

function finishVote(revealToo){
  if(state.voteLocked) return;
  const total=state.votes.reduce((a,b)=>a+b,0);
  if(total < state.totalPlayers){ toast(`Noch ${state.totalPlayers-total} Stimme(n) übrig.`); return; }
  const max=Math.max(...state.votes);
  const winners=state.votes.map((v,i)=>v===max?i:-1).filter(i=>i>=0);
  const majorityNeeded=Math.floor(state.totalPlayers/2)+1;
  const impostor=state.impostorIndex;
  const impostorHasMajority = state.votes[impostor] >= majorityNeeded;

  clearVoteHighlights();
  const rows=[...document.querySelectorAll('.voteRow')];
  if(impostorHasMajority){
    rows[impostor].classList.add('imp-win');
    setTimeout(()=>startConfettiBurst(),300);
    showVoteResult(`✅ Mehrheit richtig! ${state.names[impostor]} ist der Impostor (${state.votes[impostor]} Stimmen).`);
  }else{
    rows[impostor].classList.add('imp-lose','wrong-shake'); setTimeout(()=>rows[impostor].classList.remove('wrong-shake'),600);
    winners.forEach(i=>{ rows[i].classList.add('win-guess'); });
    showVoteResult(`❌ Falsch getippt. Mehrheit wählte: ${winners.map(i=>state.names[i]).join(', ')} (${max}). Echter Impostor: ${state.names[impostor]}.`);
  }
  if(revealToo){ $('#revealBox').style.display='block'; }
  lockVotingUI(); state.voteLocked=true; $('#btnNewRound').style.display='inline-block';
  try{ setTimeout(enterChartMode, 0); }catch(_){}
  try{ enterChartMode(); }catch(_){}
}


function showVoteResult(msg){ const res=$('#voteResult'); res.textContent=msg; res.style.display='block'; }
function clearVoteHighlights(){ document.querySelectorAll('.voteRow').forEach(r=>{ r.classList.remove('imp-win','imp-lose','wrong-shake','win-guess'); r.style.boxShadow='none'; }); }

function buildVoteList(){
  const list=$('#voteList'); const scroll=$('#voteScroll');
  list.innerHTML='';
  list.classList.toggle('twoCols', state.totalPlayers>=14);
  scroll.classList.toggle('compact', state.totalPlayers>=12);

  state.votes = Array(state.totalPlayers).fill(0);
  state.votesLeft = state.totalPlayers;
  updateVotesLeft();

  state.names.forEach((n,i)=>{
    const row=document.createElement('div'); row.className='voteRow';
    const left=document.createElement('div'); left.className='voteName'; left.textContent=n;
    const ctr=document.createElement('div'); ctr.className='voteCtr';
    const minus=document.createElement('button'); minus.className='btn btn-lite'; minus.textContent='−';
    const cnt=document.createElement('span'); cnt.className='badgeCnt'; cnt.textContent=state.votes[i];
    const plus=document.createElement('button'); plus.className='btn btn-blue'; plus.textContent='+';

    function updateButtons(){ plus.disabled = state.votesLeft<=0 || state.voteLocked; minus.disabled = state.votes[i]<=0 || state.voteLocked; }
    minus.addEventListener('click',()=>{
      if(state.votes[i]>0 && !state.voteLocked){
        state.votes[i]-=1; state.votesLeft+=1; cnt.textContent=state.votes[i]; updateVotesLeft(); updateButtons();
      }
    });
    plus.addEventListener('click',()=>{
      if(state.votesLeft>0 && !state.voteLocked){
        state.votes[i]+=1; state.votesLeft-=1; cnt.textContent=state.votes[i]; updateVotesLeft(); updateButtons();
      }
    });
    updateButtons(); ctr.append(minus,cnt,plus); row.append(left,ctr); list.appendChild(row);
  });
}
function lockVotingUI(){ document.querySelectorAll('#voteList .btn').forEach(b=> b.disabled = true); $('#btnFinishVote').disabled = true; }
function updateVotesLeft(){ $('#votesLeft').textContent=state.votesLeft; const canFinish=(state.votesLeft===0)&&!state.voteLocked; $('#btnFinishVote').disabled=!canFinish; }

/* Konfetti Burst */
function startConfettiBurst(){
  const c=document.getElementById('confettiCanvas'); const ctx=c.getContext('2d');
  const DPR=window.devicePixelRatio||1; let w=c.width=Math.floor(window.innerWidth*DPR); let h=c.height=Math.floor(window.innerHeight*DPR);
  c.style.display='block'; c.style.zIndex='99999';
  const colors=['#16a34a','#22c55e','#60a5fa','#a78bfa','#f97316','#ef4444','#eab308','#06b6d4','#10b981','#f472b6'];
  const count=Math.max(200,Math.floor(300*DPR));
  const originX=w/2, originY=h-4*DPR; const topCutoff=h*0.14;
  const parts=[];
  for(let i=0;i<count;i++){
    const angle=(-Math.PI/2)+((Math.random()-0.5)*(Math.PI/3));
    const speed=(8+Math.random()*10)*DPR;
    parts.push({x:originX+(Math.random()-0.5)*10*DPR,y:originY,vx:Math.cos(angle)*speed+(Math.random()-0.5)*0.6*DPR,vy:Math.sin(angle)*speed,g:0.18*DPR,life:700+Math.random()*350,c:colors[(Math.random()*colors.length)|0],r:3*DPR+Math.random()*3*DPR,a:Math.random()*Math.PI*2,av:-0.4+Math.random()*0.8});
  }
  function tick(){
    ctx.clearRect(0,0,w,h);
    for(let i=parts.length-1;i>=0;i--){
      const p=parts[i]; p.vy+=p.g; p.x+=p.vx; p.y+=p.vy; p.a+=p.av*0.2;
      if(p.y<topCutoff){ parts.splice(i,1); continue; }
      ctx.save(); ctx.translate(p.x,p.y); ctx.rotate(p.a); ctx.fillStyle=p.c;
      const rw=p.r*(0.6+0.8*Math.abs(Math.cos(p.a*2))); const rh=p.r*(0.6+0.8*Math.abs(Math.sin(p.a*2)));
      ctx.fillRect(-rw/2,-rh/2,rw,rh); ctx.restore();
    }
    if(parts.length===0){ c.style.display='none'; return; }
    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);
  window.addEventListener('resize',()=>{ w=c.width=Math.floor(window.innerWidth*DPR); h=c.height=Math.floor(window.innerHeight*DPR); },{once:true});
}

/* Smooth screen switch */
function show(id){
  const next=document.getElementById(id);
  const currentActive = document.querySelector('.screen.active');
  if(next===currentActive) return;
  next.classList.add('active','entering'); next.style.display='grid';
  if(currentActive){
    currentActive.classList.add('leaving');
    currentActive.addEventListener('animationend',()=>{ currentActive.classList.remove('active','leaving'); currentActive.style.display='none'; },{once:true});
  }
  next.addEventListener('animationend',()=>{ next.classList.remove('entering'); },{once:true});
}

$('#btnReset').addEventListener('click',()=> show('screenStart'));
function toast(msg){ const el=document.createElement('div'); el.textContent=msg; el.style.cssText='position:fixed;left:50%;top:8px;transform:translateX(-50%);background:#0f172a;color:#fff;padding:6px 10px;border-radius:10px;font-size:12px;opacity:.95;box-shadow:0 8px 20px rgba(0,0,0,.15);z-index:99'; document.body.appendChild(el); setTimeout(()=>el.remove(),1400); }

function init(){ state.names=Array.from({length:state.totalPlayers},(_,i)=>`Spieler ${i+1}`); buildNameInputs(); badge(); }
init();

// --- ensure mode button shows current mode on load ---
try{ document.addEventListener('DOMContentLoaded', ()=>{
  const mbtn = document.getElementById('btnShuffle');
  if(mbtn){ mbtn.textContent = 'Spielmodus: ' + (state.gameMode || 'Klassisch'); }
}); }catch(_){}


// --- Mode selection screen logic ---
document.querySelectorAll('#screenMode [data-mode]').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    state.gameMode = btn.getAttribute('data-mode');
    $('#btnShuffle').textContent = 'Spielmodus: ' + state.gameMode;
    toast('Spielmodus: ' + state.gameMode);
    show('screenStart');
  });
});
$('#btnCloseMode').addEventListener('click', ()=>{
  show('screenStart');
});


// --- Mode card selection ---
(function(){
  let pendingMode = state.gameMode || 'Klassisch'; window.pendingMode = pendingMode; window.pendingMode = pendingMode;
  function syncSelected(){
    document.querySelectorAll('#screenMode .modeCard').forEach(card=>{
      const m = card.getAttribute('data-mode');
      card.classList.toggle('selected', m === pendingMode);
    });
  }
  // Open screen: set selection to current mode
  document.addEventListener('click', (e)=>{
    if(e.target && e.target.id === 'btnShuffle'){
      pendingMode = state.gameMode || 'Klassisch'; window.pendingMode = pendingMode;
      setTimeout(syncSelected, 0);
    }
  }, {passive:true});

  // Click on cards toggles selection but does not close
  document.querySelectorAll('#screenMode .modeCard').forEach(card=>{
    card.addEventListener('click', ()=>{
      pendingMode = card.getAttribute('data-mode'); window.pendingMode = pendingMode;
      syncSelected();
    });
  });

  // Close button applies selection and closes
  const closeBtn = document.getElementById('btnCloseMode');
  if(closeBtn){
    closeBtn.addEventListener('click', ()=>{
      state.gameMode = pendingMode;
      const btn = document.getElementById('btnShuffle');
      if(btn){ btn.textContent = 'Spielmodus: ' + state.gameMode; }
      toast('Spielmodus: ' + state.gameMode);
      show('screenStart');
    });
  }
  // Ensure initial highlight if screen is shown programmatically
  document.addEventListener('DOMContentLoaded', syncSelected);
})();

// Robust delegated handler for the X close button
document.addEventListener('click', (e)=>{
  const close = e.target && e.target.closest('#btnCloseMode');
  if(close){
    try{
      // Apply pendingMode if defined in closure, else fall back to state.gameMode
      window.pendingMode = window.pendingMode || (state.gameMode || 'Klassisch');
      state.gameMode = window.pendingMode;
      const btn = document.getElementById('btnShuffle');
      if(btn){ btn.textContent = 'Spielmodus: ' + state.gameMode; }
      toast('Spielmodus: ' + state.gameMode);
    }catch(_){}
    show('screenStart');
  }
}, {passive:true});

// === Impostor helpers & slider limits ===
function isImpostor(i){
  const arr = state.impostorIndices && state.impostorIndices.length ? state.impostorIndices
            : (typeof state.impostorIndex === 'number' ? [state.impostorIndex] : []);
  return arr.includes(i);
}

function updateImpostorSliderLimits(){
  const el      = document.getElementById('impostorSlider');
  const countEl = document.getElementById('impostorCount');
  const maxLbl  = document.getElementById('impostorMaxLabel');
  if(!el) return;
  const players = Number(state?.totalPlayers || 3) || 3;
  const maxImpostors = Math.max(1, players - 1);
  el.min = '1';
  el.max = String(maxImpostors);
  let v = parseInt(el.value, 10) || 1;
  if(v > maxImpostors) v = maxImpostors;
  if(v < 1) v = 1;
  el.value = String(v);
  if(countEl) countEl.textContent = el.value;
  if(maxLbl)  maxLbl.textContent  = el.max;
  state.totalImpostors = v;
}
// Hook slider input
document.getElementById('impostorSlider')?.addEventListener('input', (e)=>{
  state.totalImpostors = parseInt(e.target.value, 10) || 1;
  const countEl = document.getElementById('impostorCount');
  if(countEl) countEl.textContent = e.target.value;
});

function pickImpostorIndices(players, impostors){
  const maxImps = Math.max(1, Math.min(impostors, players - 1));
  const pool = Array.from({length: players}, (_,i)=>i);
  for(let i=pool.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [pool[i], pool[j]] = [pool[j], pool[i]];
  }
  return pool.slice(0, maxImps);
}

// === Multi-Reveal: Reveal one impostor per click ===
function revealNextImpostor(){
  const impostors = (state.impostorIndices && state.impostorIndices.length)
    ? state.impostorIndices.slice()
    : [state.impostorIndex];
  const rows=[...document.querySelectorAll('.voteRow')];

  // find next impostor not yet revealed
  const next = impostors.find(i => !state.revealedImpostors.includes(i));
  if(next === undefined) return;

  // highlight this impostor
  rows[next]?.classList.add('imp-win');
  const name = state.names[next] || ('Spieler ' + (next+1));
  showVoteResult('✅ Impostor: ' + name + '.');

  state.revealedImpostors.push(next);
  state.revealsLeft = Math.max(0, state.revealsLeft - 1);

  const fvBtn = document.getElementById('btnFinishVote');
  if(state.revealsLeft > 0){
    if(fvBtn) fvBtn.textContent = 'Auflösen (' + state.revealsLeft + ' übrig)';
  }else{
    if(fvBtn){ fvBtn.textContent = 'Aufgelöst'; fvBtn.disabled = true; }
    // Optional: zeige das gesuchte Wort
    try{
      const box = document.getElementById('revealBox');
      const rw = document.getElementById('revealWord');
      if(box && rw){ rw.textContent = state.current?.word || '—'; box.style.display='block'; }
    }catch(e){}
    // Neue Runde Button sichtbar machen
    const nr = document.getElementById('btnNewRound');
    if(nr) nr.style.display='inline-block';
  }
}

document.getElementById('btnFinishVote')?.addEventListener('click', ()=>{ revealNextImpostor(); });

function resetVotingRound(){
  state.votes = Array(state.totalPlayers).fill(0);
  state.votesLeft = state.totalPlayers;
  state.voteLocked = false;
  document.querySelectorAll('#voteList .badgeCnt').forEach(el => el.textContent = '0');
  const vl = document.getElementById('votesLeft');
  if (vl) vl.textContent = String(state.votesLeft);
  const fvBtn = document.getElementById('btnFinishVote');
  if (fvBtn) fvBtn.disabled = true;
  if (typeof clearVoteHighlights === 'function') clearVoteHighlights();
}

function animateVoteReset(){
  const list = document.getElementById('voteList');
  if(!list) { resetVotingRound(); return; }
  list.classList.remove('vote-reset-done');
  list.classList.add('vote-resetting');
  // After the fadeOut, reset and fadeIn
  setTimeout(()=>{
    resetVotingRound();
    list.classList.remove('vote-resetting');
    list.classList.add('vote-reset-done');
    // remove the class after the fadeIn
    setTimeout(()=>{
      list.classList.remove('vote-reset-done');
    }, 280);
  }, 300);
}
</script>
<script>
// Start-safe add-on (UPDATED): Button erscheint erst NACH dem Loslassen.
// Während des Ziehens wird nur gemerkt, ob der Schwellwert überschritten wurde.
(function(){
  var THRESH = 30;
  var dragging = false, startY = 0;
  var readyToShow = false;   // neu: nur Merker beim Ziehen
  var shownLatch = false;    // verhindert Mehrfachanzeigen pro Karte
  var awaitNext = false;

  function dealActive(){
    var el = document.getElementById('screenDeal');
    return el && el.classList.contains('active');
  }
  function btn(){ return document.getElementById('btnNext'); }
  function inner(){ return document.getElementById('coverInner'); }
  function dealIndexEl(){ return document.getElementById('dealIndex'); }
  function startBtn(){ return document.getElementById('btnStart'); }

  function hideNext(){
    var b = btn(); if(!b) return;
    b.style.visibility = 'hidden';
    b.style.opacity = '0';
    b.style.transform = 'translateY(14px)';
    b.disabled = true;
    b.classList.remove('pop');
    document.body.classList.remove('btn-anchored');
  }
  function showNext(){
    var b = btn(); if(!b) return;
    b.style.visibility = 'visible';
    b.style.opacity = '1';
    b.style.transform = 'translateY(0)';
    b.disabled = false;
    if(!b.classList.contains('pop')) b.classList.add('pop');
    document.body.classList.add('btn-anchored');
  }
  function resetLatch(){
  shownLatch = false;
  awaitNext = false;
  readyToShow = false;
  var b = btn(); if(b){ b.classList.remove('btn-fading'); }
  hideNext();
  try { if(window.state) state.revealedThisTurn = false; } catch(_){ }
}

// === Build smooth horizontal bar chart after finishing vote ===
function enterChartMode(){
  const list = document.getElementById('voteList');
  if(!list) return;
  list.classList.add('chart-mode');

  const rows = Array.from(list.querySelectorAll('.voteRow'));
  const totalVotes = (window.state && Array.isArray(state.votes)) ? state.votes.slice() : rows.map(() => 0);
  const maxVote = Math.max(1, ...totalVotes);

  rows.forEach((row, i) => {
    const ctr = row.querySelector('.voteCtr');
    const name = row.querySelector('.voteName');

    // Create bar container
    const barWrap = document.createElement('div');
    barWrap.className = 'barWrap';
    const bar = document.createElement('div');
    bar.className = 'bar';
    const label = document.createElement('span');
    label.className = 'barValue';
    label.textContent = String(totalVotes[i] || 0);

    barWrap.appendChild(bar);
    barWrap.appendChild(label);

    // Insert barWrap into row, before the name (grid col 1)
    if (name) {
      row.insertBefore(barWrap, name);
    } else {
      row.appendChild(barWrap);
    }

    // Fade out controls smoothly, then remove them from layout
    if (ctr){
      // trigger CSS transition by adding chart-mode already on list
      setTimeout(()=>{
        ctr && (ctr.style.display = 'none');
      }, 320);
    }

    // Animate bar width after a short delay for layout
    const pct = Math.round(((totalVotes[i] || 0) / maxVote) * 100);
    requestAnimationFrame(()=>{
      setTimeout(()=>{
        bar.style.width = pct + '%';
      }, 60);
    });
  });
}


  function onDown(e){
    if(!dealActive()) return;
    dragging = true;
    readyToShow = false;
    startY = (e.touches ? e.touches[0].clientY : e.clientY) || 0;
  }
  function onMove(e){
    if(!dealActive() || !dragging) return;
    var currentY = (e.touches ? e.touches[0].clientY : e.clientY) || 0;
    var pull = Math.min(0, currentY - startY);
    if(pull < -THRESH && !readyToShow){
      // Setze Reveal direkt beim Erreichen der Schwelle
      readyToShow = true;
      try {
        if(window.state && !state.revealedThisTurn){
          state.revealedThisTurn = true;
          try { setUnderlayContent(); } catch(_){}
          var u = document.querySelector('#coverCard .underlay');
          if(u){ u.style.visibility=''; u.style.opacity=''; }
          document.body.classList.remove('underlay-hidden');
        }
      } catch(_){}
    }
  }
  function onUp(){
    if(!dragging) return;
    dragging = false;
    if(readyToShow && !shownLatch){
      shownLatch = true;
      showNext();
      try { if(window.state) state.revealedThisTurn = true; } catch(_){}
    }else{
      hideNext();
    }
  }

  // Beim Klick auf "Weitergeben": sofort verstecken und auf nächste Karte warten
  window.addEventListener('click', function(e){
  if(e.target && e.target.id === 'btnNext'){
    var b = btn(); if(b){ b.classList.add('btn-fading'); b.disabled = true; }
    // Wichtig: Layout (btn-anchored) bleibt bestehen, bis der Index wechselt.
    awaitNext = true;
  }
}, true);

  // Beobachte die Spieleranzeige (dealIndex). Wenn sie sich ändert -> neue Karte -> zurücksetzen
  var idxNode = dealIndexEl();
  if(idxNode){
    var mo = new MutationObserver(function(){
      if(dealActive()){
        resetLatch();
      }
    });
    mo.observe(idxNode, { characterData: true, subtree: true, childList: true });
  }

  // Beim Aktivieren/Verlassen des Deal-Screens ebenfalls resetten
  var screenDeal = document.getElementById('screenDeal');
  if(screenDeal){
    var mo2 = new MutationObserver(function(){
      resetLatch();
    });
    mo2.observe(screenDeal, { attributes: true, attributeFilter: ['class'] });
  }

  // Beim Start-Button (neues Spiel) Latch sauber zurücksetzen
  var sb = startBtn();
  if(sb){
    sb.addEventListener('click', function(){ resetLatch(); }, { passive: true });
  }

  // Fallback-Intervall (belassen, aber ohne Anzeige während Move)
  setInterval(function(){
    if(!dealActive()){
      hideNext();
      return;
    }
  }, 300);

  // Events binden (nur Kartenseite)
  function bind(){
    var el = inner(); if(!el) return;
    el.addEventListener('touchstart', onDown, {passive:true});
    el.addEventListener('mousedown', onDown, {passive:true});
    window.addEventListener('touchmove', onMove, {passive:true});
    window.addEventListener('mousemove', onMove, {passive:true});
    window.addEventListener('touchend', onUp, {passive:true});
    window.addEventListener('mouseup', onUp, {passive:true});
  }
  if (document.readyState === 'complete' || document.readyState === 'interactive'){
    setTimeout(bind, 60);
  } else {
    document.addEventListener('DOMContentLoaded', bind);
  }

  // Initialzustand
  hideNext();
})();
</script>
<script>
// Pure pull control (UPDATED): Button erscheint erst NACH dem Loslassen.
// Während des Ziehens wird kein Button eingeblendet oder positioniert.
(function(){
  var dragging=false, startY=0, btnH=null, GAP=6;
  var reached=false, anchored=false;

  function inDeal(){ var el=document.getElementById('screenDeal'); return el && el.classList.contains('active'); }
  function inner(){ return document.getElementById('coverInner'); }
  function btn(){ return document.getElementById('btnNext'); }
  function dealIndexEl(){ return document.getElementById('dealIndex'); }

  function measureBtn(){
    var b=btn(); if(!b) return 56;
    var prevDisp=b.style.display, prevVis=b.style.visibility, prevDis=b.disabled;
    b.style.display='inline-block'; b.style.visibility='hidden'; b.disabled=true;
    var h=b.offsetHeight||56;
    b.style.display=prevDisp||''; b.style.visibility=prevVis||''; b.disabled=prevDis;
    return (h+GAP);
  }

  function finalizeShow(){
    var b=btn(); if(!b) return;
    b.style.visibility='visible';
    b.style.opacity='1';
    b.style.transform='translateY(0px)';
    b.disabled=false;
    anchored=true;
    document.body.classList.add('btn-anchored');
    try{ if(window.state) state.revealedThisTurn = true; }catch(_){}
  }

  function hideBtn(){
    var b=btn(); if(!b) return;
    b.style.opacity='0';
    b.style.transform='translateY(14px)';
    b.style.visibility='hidden';
    b.disabled=true;
    anchored=false;
    document.body.classList.remove('btn-anchored');
  }

  function onDown(e){
    if(!inDeal()) return;
    dragging=true;
    anchored=false;
    reached=false;
    startY=(e.touches?e.touches[0].clientY:e.clientY)||0;
    if(btnH==null) btnH=measureBtn();
  }
  function onMove(e){
    if(!dragging || !inDeal()) return;
    var y=(e.touches?e.touches[0].clientY:e.clientY)||0;
    var delta = startY - y; // positiv nach oben
    if(delta <= 2){ reached=false; return; }
    var need=btnH || measureBtn();
    // Nur merken, ob Schwelle erreicht; NICHT einblenden
    reached = (delta >= need);
    // Sofort anzeigen, damit Text während des Ziehens sichtbar wird
    try {
      if(reached && window.state && !state.revealedThisTurn){
        state.revealedThisTurn = true;
        try { setUnderlayContent(); } catch(_){}
        var u = document.querySelector('#coverCard .underlay');
        if(u){ u.style.visibility=''; u.style.opacity=''; }
        document.body.classList.remove('underlay-hidden');
      }
    } catch(_){}
  }
  function onUp(){
    if(!dragging) return;
    dragging=false;
    if(reached){
      finalizeShow();
    }else{
      hideBtn();
    }
  }

  window.addEventListener('click', function(e){
    if(e.target && e.target.id==='btnNext'){
      hideBtn();
      reached=false; anchored=false;
    }
  }, true);

  var idx=dealIndexEl();
  if(idx){
    var mo=new MutationObserver(function(){
      if(inDeal()){
        reached=false; anchored=false; btnH=null; hideBtn();
      }
    });
    mo.observe(idx,{childList:true,subtree:true,characterData:true});
  }

  var d=document.getElementById('screenDeal');
  if(d){
    var mo2=new MutationObserver(function(){
      if(!inDeal()){ reached=false; anchored=false; hideBtn(); }
    });
    mo2.observe(d,{attributes:true,attributeFilter:['class']});
  }

  function bind(){
    var el=inner(); if(!el) return;
    el.addEventListener('touchstart', onDown, {passive:true});
    el.addEventListener('mousedown', onDown, {passive:true});
    window.addEventListener('touchmove', onMove, {passive:true});
    window.addEventListener('mousemove', onMove, {passive:true});
    window.addEventListener('touchend', onUp, {passive:true});
    window.addEventListener('mouseup', onUp, {passive:true});
  }
  if(document.readyState==='complete' || document.readyState==='interactive'){ setTimeout(bind,60); } else { document.addEventListener('DOMContentLoaded', bind); }

  hideBtn();
})();
</script>
<script>
// Pretty bottom-edge lift (disabled to avoid tiny shift after pull/release)
(function(){
  // We keep a minimal observer to maintain compatibility but do not animate transforms.
  var mo = new MutationObserver(function(){});
  mo.observe(document.body, { attributes:true, attributeFilter:['class'] });
})();
</script>
<script>
// Safeguard: after user releases the pull, ensure card wrapper has no transform
(function(){
  var inner = document.getElementById('coverInner');
  if(!inner) return;
  function onUp(){ try{ var c=document.getElementById('coverCard'); if(c){ c.style.transform=''; } }catch(e){} }
  window.addEventListener('mouseup', onUp, {passive:true});
  window.addEventListener('touchend', onUp, {passive:true});
})();
</script>
<script>
// Trigger slide-up animation on #nextRow whenever the Next button becomes anchored (body.btn-anchored)
(function(){
  var row = document.getElementById('nextRow');
  if(!row) return;
  var animating = false;

  function trigger(){
    if(!row) return;
    // restart animation
    row.classList.remove('animate-in');
    // force reflow
    void row.offsetWidth;
    row.classList.add('animate-in');
  }

  var mo = new MutationObserver(function(muts){
    muts.forEach(function(m){
      if(m.attributeName === 'class'){
        var anchored = document.body.classList.contains('btn-anchored');
        if(anchored){
          trigger();
        } else {
          row.classList.remove('animate-in');
        }
      }
    });
  });
  mo.observe(document.body, { attributes:true, attributeFilter:['class'] });
})();
</script>
<script>
// Remove any 'pop' class from the Next button to avoid size jump; keep behavior smooth.
(function(){
  var btn = document.getElementById('btnNext');
  if(!btn) return;
  function stripPop(){
    if(btn.classList.contains('pop')) btn.classList.remove('pop');
  }
  // Initial cleanup
  stripPop();
  // Observe future class changes
  var mo = new MutationObserver(function(muts){
    muts.forEach(function(m){
      if(m.attributeName === 'class') stripPop();
    });
  });
  mo.observe(btn, { attributes:true, attributeFilter:['class'] });
})();
</script>
<script>
// Override: ensure underlay is completely invisible from click until new card finishes
(function(){
  window.animateSlideToNext = function(updateFn){
    const card = document.getElementById('coverCard');
    if(!card){ try{ updateFn && updateFn(); }catch(_){ } return; }
    const underlay = card.querySelector('.underlay');
    const inner    = card.querySelector('.coverInner');
    if(!underlay || !inner){ try{ updateFn && updateFn(); }catch(_){ } return; }

    // Hide underlay immediately and globally prevent visibility during the whole transition
    document.body.classList.add('underlay-hidden');
    underlay.style.visibility = 'hidden';
    underlay.style.opacity = '0';

    // Clone old content for fade-out (visual continuity)
    const layer = document.createElement('div');
    layer.style.position = 'absolute';
    layer.style.inset = '0';
    layer.style.overflow = 'hidden';
    layer.style.pointerEvents = 'none';
    layer.style.zIndex = '5';

    const oldUnder = underlay.cloneNode(true);
    const oldInner = inner.cloneNode(true);
    [oldUnder, oldInner].forEach(L => L.querySelectorAll('[id]').forEach(el => el.removeAttribute('id')));

    layer.appendChild(oldUnder);
    layer.appendChild(oldInner);
    card.appendChild(layer);

    // Update content to next
    try{ updateFn && updateFn(); }catch(_){}

    // Prepare new card above
    [underlay, inner].forEach(el => {
      el.style.transition = 'none';
      el.style.transform = 'translateY(-140%)';
      el.style.willChange = 'transform';
    });

    // Prepare old card for fade-out
    [oldUnder, oldInner].forEach(el => {
      el.style.transition = 'opacity 0.4s ease';
      el.style.opacity = '1';
    });

    // Animate: fade old, slide new
    requestAnimationFrame(()=>{
      [oldUnder, oldInner].forEach(el => { el.style.opacity = '0'; });
      const D = 600, E = 'cubic-bezier(.22,1,.36,1)';
      [underlay, inner].forEach(el => {
        el.style.transition = `transform ${D}ms ${E}`;
        el.style.transform = 'translateY(0)';
      });

      const onDone = () => {
        // Reveal underlay instantly only after slide completes
        underlay.style.visibility = '';
        underlay.style.opacity = '';
        document.body.classList.remove('underlay-hidden');

        [underlay, inner].forEach(el => {
          el.style.transition = '';
          el.style.transform = '';
          el.style.willChange = '';
        });
        if(layer && layer.parentNode){ layer.parentNode.removeChild(layer); }
        
        // After slide completes, if odd total and we're on last player, pulse the card
        try{
          if(window.state && (state.totalPlayers % 2 === 1) && (state.currentIndex === state.totalPlayers - 1)){
            var card = document.getElementById('coverCard');
            if(card){
              card.classList.add('fullwidth-anim');
              card.addEventListener('animationend', function(){ card.classList.remove('fullwidth-anim'); }, { once:true });
            }
          }
        }catch(_){}

        inner.removeEventListener('transitionend', onDone);
      };
      inner.addEventListener('transitionend', onDone, { once:true });
    });
  };
})();
</script>
<script>
// Helper: when the deal screen becomes active (e.g., after Start), apply the pulse if it's already the last player.
(function(){
  var screenDeal = document.getElementById('screenDeal');
  if(!screenDeal) return;
  var mo = new MutationObserver(function(muts){
    muts.forEach(function(m){
      if(m.attributeName === 'class' && screenDeal.classList.contains('active')){
        try{
          if(window.state && (state.totalPlayers % 2 === 1) && (state.currentIndex === state.totalPlayers - 1)){
            var card = document.getElementById('coverCard');
            if(card){
              card.classList.add('fullwidth-anim');
              card.addEventListener('animationend', function(){ card.classList.remove('fullwidth-anim'); }, { once:true });
            }
          }
        }catch(_){}
      }
    });
  });
  mo.observe(screenDeal, { attributes:true, attributeFilter:['class'] });
})();
</script>
<script>
// === Flip reveal via state setter (no reliance on event wrappers) ===
(function(){
  function tiltOn(){
    var card = document.getElementById('coverCard'); if(!card) return;
    if(!card.classList.contains('flip-tilt')) card.classList.add('flip-tilt');
  }
  function tiltOff(){
    var card = document.getElementById('coverCard'); if(!card) return;
    if(card.classList.contains('flip-tilt')){
      card.classList.add('release');
      var off = function(){
        card.classList.remove('flip-tilt','release');
        card.removeEventListener('transitionend', off);
      };
      card.addEventListener('transitionend', off, { once:true });
      setTimeout(()=>{ card && card.classList.remove('flip-tilt','release'); }, 360);
    }
  }
  function safeSetup(){
    try{
      if(!window.state) return false;
      var backing = state.revealedThisTurn;
      // Avoid double-defining
      var desc = Object.getOwnPropertyDescriptor(state, 'revealedThisTurn');
      if(desc && !desc.configurable && !desc.set) return true;
      var _val = backing;
      Object.defineProperty(state, 'revealedThisTurn', {
        configurable: true,
        get(){ return _val; },
        set(v){
          _val = v;
          if(v){
            tiltOn();
            try{ triggerWordPulse(); }catch(_){}
            try{ startImpostorParticles(); }catch(_){}
          } else {
            tiltOff();
          }
        }
      });
      // initial sync
      if(backing){ tiltOn(); } else { tiltOff(); }
      return true;
    }catch(e){ return false; }
  }
  // Try immediately, else retry shortly until state is ready
  if(!safeSetup()){
    var tries = 0, t = setInterval(function(){
      tries++; if(safeSetup() || tries>40) clearInterval(t);
    }, 50);
  }
  // Always release on pointer up and when leaving the deal screen
  window.addEventListener('mouseup', tiltOff, { passive:true });
  window.addEventListener('touchend', tiltOff, { passive:true });
  var screenDeal = document.getElementById('screenDeal');
  if(screenDeal){
    new MutationObserver(function(muts){
      muts.forEach(function(m){
        if(m.attributeName==='class' && !screenDeal.classList.contains('active')){ tiltOff(); }
      });
    }).observe(screenDeal, { attributes:true, attributeFilter:['class'] });
  }
})();
</script>
<script>
</script>
<script>
// === Idle wiggle logic (10s) on deal screen ===
(function(){
  const DELAY = 10000; // 10 seconds
  let t = null;
  const inner = () => document.getElementById('coverInner');
  const inDeal = () => {
    const el = document.getElementById('screenDeal');
    return el && el.classList.contains('active');
  };

  function setIdle(){
    if(!inDeal()) return;
    const el = inner();
    if(el) el.classList.add('idle-wiggle');
  }
  function clearIdle(){
    const el = inner();
    if(el) el.classList.remove('idle-wiggle');
  }
  function reset(){
    if(t) clearTimeout(t);
    clearIdle();
    if(inDeal()){
      t = setTimeout(setIdle, DELAY);
    }
  }

  // Reset on user interactions
  ['mousemove','touchmove','mousedown','touchstart','keydown'].forEach(evt => {
    window.addEventListener(evt, reset, { passive: true });
  });

  // Observe entering/leaving the deal screen
  const sd = document.getElementById('screenDeal');
  if(sd){
    new MutationObserver(() => reset()).observe(sd, { attributes:true, attributeFilter:['class'] });
  }

  // Also reset when player index changes (new card)
  const idx = document.getElementById('dealIndex');
  if(idx){
    new MutationObserver(() => reset()).observe(idx, { childList:true, subtree:true, characterData:true });
  }

  // Initial start
  reset();
})();
// === end idle wiggle logic ===
</script>
<script>
// === Safety: ensure reveal on fast flicks + force underlay visible ===
(function(){
  const THRESH = 30; // same threshold as the main pull logic
  const inner = document.getElementById('coverInner');
  const card  = document.getElementById('coverCard');
  const deal  = document.getElementById('screenDeal');
  if(!inner || !card || !deal) return;

  let startY = 0;
  let dragging = false;

  function getUnderlay(){ return card.querySelector('.underlay'); }

  function onDown(e){
    dragging = true;
    startY = (e.touches ? e.touches[0].clientY : e.clientY) || 0;
  }
  function onUp(e){
    if(!dragging) return;
    dragging = false;
    const endY = (e.changedTouches ? e.changedTouches[0].clientY : (e.clientY || startY));
    const delta = startY - endY; // positive if moved up
    // If fast pull exceeded threshold but state.revealedThisTurn not set, set it now
    try {
      if (deal.classList.contains('active') && delta >= THRESH) {
        if (!window.state.revealedThisTurn) {
          window.state.revealedThisTurn = true;
          // Make sure underlay content is up to date and visible
          try { setUnderlayContent(); } catch(_){}
        }
      }
    } catch(_){}

    // Always force underlay visible after pointer up on deal screen
    try {
      const u = getUnderlay();
      if (u) {
        u.style.visibility = '';
        u.style.opacity = '';
      }
      document.body.classList.remove('underlay-hidden');
    } catch(_){}
  }

  inner.addEventListener('mousedown', onDown, {passive:true});
  inner.addEventListener('touchstart', onDown, {passive:true});
  window.addEventListener('mouseup', onUp, {passive:true});
  window.addEventListener('touchend', onUp, {passive:true});
})();
// === end safety ===
</script>
<script>
// === Micro-check: ensure word text is present when entering deal screen ===
(function(){
  const deal = document.getElementById('screenDeal');
  if(!deal) return;
  const w = () => document.getElementById('wordOut');
  new MutationObserver(()=>{
    if(deal.classList.contains('active')){
      const el = w();
      if (el && (!el.textContent || el.textContent.trim() === '—')) {
        try { setUnderlayContent(); } catch(_){}
      }
    }
  }).observe(deal, { attributes:true, attributeFilter:['class'] });
})();
// === end micro-check ===
</script>
<script>
/* === v11 base: v9 Kombi-Fix — Overlay-Chart + robuster Reset & Wrapping === */
(function(){
  function getRowValue(row, index){
    const cnt = row.querySelector('.badgeCnt');
    const domVal = cnt ? parseInt(cnt.textContent, 10) : NaN;
    if (!isNaN(domVal)) return domVal;
    if (window.state && Array.isArray(state.votes)) return state.votes[index] || 0;
    return 0;
  }
  function ensureOverlay(row, nameText){
    let overlay = row.querySelector('.barOverlay');
    if (!overlay){
      overlay = document.createElement('div');
      overlay.className = 'barOverlay';
      const barWrap = document.createElement('div');
      barWrap.className = 'barWrap';
      const bar = document.createElement('div');
      bar.className = 'bar';
      const label = document.createElement('span');
      label.className = 'barValue';
      label.textContent = '0';
      barWrap.appendChild(bar);
      barWrap.appendChild(label);
      const ghost = document.createElement('div');
      ghost.className = 'nameGhost';
      ghost.textContent = nameText || '';
      overlay.appendChild(barWrap);
      overlay.appendChild(ghost);
      row.appendChild(overlay);
    } else {
      const bar = overlay.querySelector('.bar');
      const label = overlay.querySelector('.barValue');
      const ghost = overlay.querySelector('.nameGhost');
      if (bar) bar.style.width = '0%';
      if (label) label.textContent = '0';
      if (ghost) ghost.textContent = nameText || '';
      overlay.style.opacity = 0;
      overlay.style.transform = 'translateY(6px)';
    }
    return overlay;
  }
  window.enterChartMode = function enterChartMode(){
    const list = document.getElementById('voteList');
    if(!list) return;

    const rows = Array.from(list.querySelectorAll('.voteRow'));
    const values = rows.map((row, i) => getRowValue(row, i));
    const maxVote = Math.max(1, ...values);

    list.classList.add('chart-mode');

    rows.forEach((row, i) => {
      const nameEl = row.querySelector('.voteName');
      const nameText = nameEl ? nameEl.textContent : '';
      ensureOverlay(row, nameText);
    });

    rows.forEach((row, i) => {
      const overlay = row.querySelector('.barOverlay');
      const bar = overlay && overlay.querySelector('.bar');
      const label = overlay && overlay.querySelector('.barValue');
      const val = values[i] || 0;
      const pct = Math.round((val / maxVote) * 100);
      const delay = 120 + i * 70;
      setTimeout(()=>{
        if (!overlay || !bar || !label) return;
        overlay.style.opacity = 1;
        overlay.style.transform = 'translateY(0)';
        label.textContent = String(val);
        setTimeout(()=>{ bar.style.width = pct + '%'; }, 70);
      }, delay);
    });
  };
  function resetVoteScreen(){
    const list = document.getElementById('voteList');
    if (list){
      list.classList.remove('chart-mode');
      const rows = Array.from(list.querySelectorAll('.voteRow'));
      rows.forEach(row => {
        row.querySelectorAll('.barOverlay').forEach(o => o.remove());
        const name = row.querySelector('.voteName');
        const ctr  = row.querySelector('.voteCtr');
        if (name){ name.style.visibility=''; name.style.opacity=''; name.style.transform=''; }
        if (ctr){ ctr.style.visibility=''; ctr.style.opacity=''; ctr.style.pointerEvents=''; ctr.style.display=''; }
      });
    }
    document.querySelectorAll('.barOverlay').forEach(o => o.remove());
    document.body.style.pointerEvents = '';
    document.body.classList.remove('btn-anchored', 'underlay-hidden');
    const conf = document.getElementById('confettiCanvas');
    if (conf){ conf.style.display = 'none'; }
  }
  function wrapBuildVoteListOnce(){
    if (wrapBuildVoteListOnce._wrapped) return true;
    if (typeof window.buildVoteList === 'function'){
      const _orig = window.buildVoteList;
      window.buildVoteList = function(){
        resetVoteScreen();
        return _orig.apply(this, arguments);
      };
      wrapBuildVoteListOnce._wrapped = true;
      return true;
    }
    return false;
  }
  if (!wrapBuildVoteListOnce()){
    let tries = 0;
    const id = setInterval(()=>{
      tries++;
      if (wrapBuildVoteListOnce() || tries > 50){
        clearInterval(id);
      }
    }, 100);
    window.addEventListener('load', wrapBuildVoteListOnce, { once:true });
  }
  (function wrapShow(){
    function doWrap(){
      if (typeof window.show === 'function' && !wrapShow._wrapped){
        const _origShow = window.show;
        window.show = function(id){
          resetVoteScreen();
          try { return _origShow.call(this, id); }
          finally { document.body.style.pointerEvents = ''; }
        };
        wrapShow._wrapped = true;
      }
    }
    if (!doWrap()){
      window.addEventListener('load', doWrap, { once:true });
      let tries = 0;
      const iv = setInterval(()=>{
        tries++;
        if (typeof window.show === 'function'){
          doWrap();
          clearInterval(iv);
        }
        if (tries > 50) clearInterval(iv);
      }, 100);
    }
  })();
  document.addEventListener('click', function(ev){
    const t = ev.target;
    if (!t) return;
    if (t.id === 'btnNewRound' || t.id === 'btnStart' || t.id === 'btnReset'){
      resetVoteScreen();
    }
  }, true);
})();
</script>
<script>
/* === v11 includes v10 UI Polish JS: micro-interactions for Vote-Screen === */
(function(){
  const observer = new MutationObserver((muts)=>{
    muts.forEach(m=>{
      if (m.type === 'childList' && m.target && m.target.classList && m.target.classList.contains('badgeCnt')){
        const el = m.target;
        el.classList.remove('pulse');
        void el.offsetWidth;
        el.classList.add('pulse');
        setTimeout(()=> el.classList.remove('pulse'), 220);
      }
    });
  });
  function observeBadges(){
    document.querySelectorAll('#voteList .badgeCnt').forEach(el=>{
      observer.observe(el, { childList:true });
    });
  }
  function revealRows(){
    const rows = Array.from(document.querySelectorAll('#voteList .voteRow'));
    rows.forEach((row, i)=>{
      row.style.opacity = 0;
      row.style.transform = 'translateY(6px)';
      setTimeout(()=>{
        row.style.transition = 'opacity .22s ease, transform .22s ease';
        row.style.opacity = 1;
        row.style.transform = 'translateY(0)';
        setTimeout(()=>{ row.style.transition = ''; }, 260);
      }, 30 + i*18);
    });
  }
  function wrapBuildOnce(){
    if (wrapBuildOnce._wrapped) return true;
    if (typeof window.buildVoteList === 'function'){
      const _orig = window.buildVoteList;
      window.buildVoteList = function(){
        const ret = _orig.apply(this, arguments);
        requestAnimationFrame(()=>{
          observeBadges();
          revealRows();
        });
        return ret;
      };
      wrapBuildOnce._wrapped = true;
      return true;
    }
    return false;
  }
  if (!wrapBuildOnce()){
    let tries = 0;
    const iv = setInterval(()=>{
      tries++;
      if (wrapBuildOnce() || tries > 50){
        clearInterval(iv);
      }
    }, 100);
    window.addEventListener('load', wrapBuildOnce, { once:true });
  }
})();
</script>
<script>
/* === v14: setze Row-Lift nur beim PLUS-Klick === */
(function(){
  document.addEventListener('click', function(ev){
    const btn = ev.target && ev.target.closest('.voteCtr .btn');
    if (!btn) return;
    // Erkenne PLUS-Knopf über sichtbares Label "+"
    const label = (btn.textContent || '').trim();
    const isPlus = label === '+';
    if (!isPlus) return; // Minus & andere Buttons: kein Lift

    const row = btn.closest('.voteRow');
    if (!row) return;
    row.classList.add('bump');
    // Nach kurzer Zeit wieder entfernen
    setTimeout(()=> row.classList.remove('bump'), 260);
  }, true);
})();
</script>
<script>
// === Robust close and selection apply for Mode Screen ===
(function(){
  function applyAndClose(){
    try{
      // Prefer pendingMode if it exists, fall back to state.gameMode
      var chosen = (window.pendingMode) ? window.pendingMode : (state.gameMode || 'Klassisch');
      state.gameMode = chosen;
      var btn = document.getElementById('btnShuffle');
      if(btn){ btn.textContent = 'Spielmodus: ' + state.gameMode; }
      toast('Spielmodus: ' + state.gameMode);
    }catch(_){}
    show('screenStart');
  }
  function syncPending(){
    window.pendingMode = state.gameMode || 'Klassisch';
    document.querySelectorAll('#screenMode .modeCard').forEach(function(card){
      var m = card.getAttribute('data-mode');
      card.classList.toggle('selected', m === window.pendingMode);
    });
  }
  document.addEventListener('DOMContentLoaded', function(){
    // Attach reliable click handlers
    var x = document.getElementById('btnCloseMode');
    if(x){
      x.onclick = function(e){ e.preventDefault(); applyAndClose(); };
      x.ontouchstart = function(e){ e.preventDefault(); applyAndClose(); };
    }
    // Card clicks update pending selection
    document.querySelectorAll('#screenMode .modeCard').forEach(function(card){
      card.onclick = function(){ window.pendingMode = card.getAttribute('data-mode'); syncPending(); };
      card.ontouchstart = function(){ window.pendingMode = card.getAttribute('data-mode'); syncPending(); };
    });
    // When opening the screen via the Spielmodus button, sync selection
    var openBtn = document.getElementById('btnShuffle');
    if(openBtn){
      openBtn.addEventListener('click', function(){ setTimeout(syncPending, 0); });
    }
    // Initial sync
    syncPending();
  });
})();
</script><script>
// Ensure card clicks do not close the screen
document.addEventListener('DOMContentLoaded', function(){
  document.querySelectorAll('#screenMode .modeCard').forEach(function(card){
    card.addEventListener('click', function(e){
      e.preventDefault();
      e.stopPropagation();
      window.pendingMode = card.getAttribute('data-mode');
      document.querySelectorAll('#screenMode .modeCard').forEach(function(c){
        c.classList.toggle('selected', c.getAttribute('data-mode') === window.pendingMode);
      });
    });
  });
});
</script><script>
// --- Force mode cards to NOT close the screen ---
document.addEventListener('DOMContentLoaded', function(){
  var cards = document.querySelectorAll('#screenMode .modeCard');
  cards.forEach(function(card){
    // Remove all inline onclick/ontouch attributes if present
    card.onclick = null;
    card.ontouchstart = null;
    // Add our controlled click logic
    card.addEventListener('click', function(e){
      e.preventDefault();
      e.stopPropagation();
      window.pendingMode = card.getAttribute('data-mode');
      cards.forEach(function(c){
        c.classList.toggle('selected', c.getAttribute('data-mode') === window.pendingMode);
      });
    }, {capture:true});
    card.addEventListener('touchstart', function(e){
      e.preventDefault();
      e.stopPropagation();
      window.pendingMode = card.getAttribute('data-mode');
      cards.forEach(function(c){
        c.classList.toggle('selected', c.getAttribute('data-mode') === window.pendingMode);
      });
    }, {capture:true});
  });

  // Ensure only the X button closes the screen
  var closeBtn = document.getElementById('btnCloseMode');
  if(closeBtn){
    closeBtn.addEventListener('click', function(e){
      e.preventDefault();
      e.stopPropagation();
      var chosen = window.pendingMode || state.gameMode || 'Klassisch';
      state.gameMode = chosen;
      var btn = document.getElementById('btnShuffle');
      if(btn){ btn.textContent = 'Spielmodus: ' + state.gameMode; }
      toast('Spielmodus: ' + state.gameMode);
      show('screenStart');
    }, {capture:true});
    closeBtn.addEventListener('touchstart', function(e){
      e.preventDefault();
      e.stopPropagation();
      var chosen = window.pendingMode || state.gameMode || 'Klassisch';
      state.gameMode = chosen;
      var btn = document.getElementById('btnShuffle');
      if(btn){ btn.textContent = 'Spielmodus: ' + state.gameMode; }
      toast('Spielmodus: ' + state.gameMode);
      show('screenStart');
    }, {capture:true});
  }
});
</script>
<!-- === Simple Reveal Mode Patch (keeps start screen unchanged) === -->
<script>
(function(){
  // Guard if already patched
  if (window.__revealPatchApplied) return;
  window.__revealPatchApplied = true;

  function safeSel(id){ return document.getElementById(id); }
  function has(arr, v){ return Array.isArray(arr) && arr.indexOf(v) !== -1; }

  // Hide voting UI & prepare reveal UI when the discuss screen becomes active
  function setupDiscussForReveal(){
    try {
      var voteTop = document.querySelector('#screenDiscuss .voteTop');
      var voteScroll = document.getElementById('voteScroll');
      var toggleCompact = document.getElementById('toggleCompact');
      var btnFinish = document.getElementById('btnFinishVote');
      var btnNewRound = document.getElementById('btnNewRound');
      var voteList = document.getElementById('voteList');
      var votePanel = document.getElementById('votePanel');
      var voteResult = document.getElementById('voteResult');
      var votesLeft = document.getElementById('votesLeft');

      if (voteTop) voteTop.style.display = 'none';
      if (voteScroll) voteScroll.style.maxHeight = 'unset';
      if (toggleCompact) toggleCompact.style.display = 'none';
      if (votesLeft) votesLeft.textContent = '—';
      if (voteResult) voteResult.style.display = 'none';
      if (votePanel) votePanel.style.display = 'block';

      if (btnFinish){
        btnFinish.disabled = false;
        btnFinish.textContent = 'Aufdecken';
        btnFinish.onclick = function(){
          try { revealImpostors(); } catch(e){ console.error(e); }
        };
      }
      if (btnNewRound){
        btnNewRound.style.display = 'none';
      }
      if (voteList){
        // Clear any previous content and show a hint
        
      }
    } catch(e){ console.error('setupDiscussForReveal failed', e); }
  }

  // Build a simple list where impostors are highlighted.
  function revealImpostors(){
    try {
      var voteList = safeSel('voteList');
      var revealWord = safeSel('revealWord');
      var revealBox = safeSel('revealBox');
      var btnNewRound = safeSel('btnNewRound');
      var btnFinish = safeSel('btnFinishVote');

      // Fallbacks if state is missing
      var names = (window.state && Array.isArray(window.state.names)) ? window.state.names : [];
      var total = (window.state && +window.state.totalPlayers) || names.length;
      if (names.length < total){
        for (var i = names.length; i < total; i++){ names.push('Spieler ' + (i+1)); }
      }
      var impostorIndices = (window.state && (window.state.impostorIndices || (typeof window.state.impostorIndex === 'number' ? [window.state.impostorIndex] : []))) || [];
      var word = (window.state && window.state.current && window.state.current.word) ? window.state.current.word : '—';

      // Render
      var html = '';
      for (var i = 0; i < names.length; i++){
        var isImp = has(impostorIndices, i);
        html += '<div class="voteRow ' + (isImp ? 'imp-win' : '') + '">' +
                  '<span class="voteName">' + names[i] + '</span>' +
                  '<span class="pill">' + (isImp ? 'Impostor' : 'Crew') + '</span>' +
                '</div>';
      }
      if (voteList) voteList.innerHTML = html;
      if (revealWord) revealWord.textContent = word;
      if (revealBox) revealBox.style.display = 'block';
      if (btnNewRound) btnNewRound.style.display = 'inline-block';
      if (btnFinish) { btnFinish.disabled = true; btnFinish.textContent = 'Aufgedeckt'; }
    } catch(e){ console.error('revealImpostors failed', e); }
  }
  window.revealImpostors = revealImpostors;

  // Patch the screen switcher so that whenever DISCUSS opens, we prep the reveal UI
  function attachShowHook(){
    try{
      var tried = 0;
      var t = setInterval(function(){
        tried++;
        if (typeof window.show === 'function'){
          clearInterval(t);
          var orig = window.show;
          window.show = function(id){
            var res = orig.apply(this, arguments);
            if (id === 'screenDiscuss'){ setupDiscussForReveal(); }
            return res;
          };
        } else if (tried > 200){ // ~10s max
          clearInterval(t);
          // Fallback: do a one-time setup in case discuss is already visible
          var discuss = document.getElementById('screenDiscuss');
          if (discuss && /\bactive\b/.test(discuss.className)){ setupDiscussForReveal(); }
        }
      }, 50);
    }catch(e){ console.error('attachShowHook failed', e); }
  }

  // If the DOM is ready, attach now; otherwise wait.
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', attachShowHook, { once:true });
  } else {
    attachShowHook();
  }
})();
</script>

<script>
(function(){
  if (window.__revealPatchV2) return;
  window.__revealPatchV2 = true;

  function setupDiscussForReveal(){
    try {
      var btnFinish = document.getElementById('btnFinishVote');
      var btnNewRound = document.getElementById('btnNewRound');
      var voteTop = document.querySelector('#screenDiscuss .voteTop');
      var toggleCompact = document.getElementById('toggleCompact');
      var voteList = document.getElementById('voteList');
      var voteResult = document.getElementById('voteResult');
      var voteScroll = document.getElementById('voteScroll');

      if (voteTop) voteTop.style.display = 'none';
      if (toggleCompact) toggleCompact.style.display = 'none';
      if (voteResult) voteResult.style.display = 'none';
      if (voteScroll) voteScroll.style.maxHeight = 'unset';

      if (btnNewRound) btnNewRound.style.display = 'none';

      if (btnFinish){
        btnFinish.disabled = false;
        btnFinish.removeAttribute('disabled');
        btnFinish.style.pointerEvents = 'auto';
        btnFinish.textContent = 'Aufdecken';
        btnFinish.onclick = function(){
          try { window.revealImpostors && window.revealImpostors(); } catch(e){ console.error(e); }
        };
      }

      if (voteList && !voteList.__revealIniti
<script>
(function(){
  if (window.__revealAnimV3) return;
  window.__revealAnimV3 = true;

  function clearTextUnderButton(){
    try{
      var revealBox = document.getElementById('revealBox');
      if (revealBox){ revealBox.style.display = 'none'; revealBox.innerHTML=''; }
      var voteResult = document.getElementById('voteResult');
      if (voteResult){ voteResult.style.display='none'; voteResult.innerHTML=''; }
    }catch(e){}
  }

  function makeCard(name, big, delayMs){
    var card = document.createElement('div');
    card.className = 'revealCard ' + (big ? 'big' : 'small');
    card.style.animationDelay = (delayMs||0)+'ms';
    card.innerHTML = '<div>'+name+'</div><div class="revealTag">Impostor</div>';
    return card;
  }

  function ensureRevealArea(single){
    var voteList = document.getElementById('voteList');
    var area = document.getElementById('revealArea');
    if (!area){
      area = document.createElement('div');
      area.id = 'revealArea';
      // Place it where the list used to be
      if (voteList && voteList.parentElement){
        
        voteList.__revealInitialized = true;
      }
    } catch(e){ console.error('setupDiscussForReveal(v2) failed', e); }
  }
  window.__setupDiscussForRevealV2 = setupDiscussForReveal;

  // Run immediately if discuss screen is already visible
  function runIfActive(){
    var discuss = document.getElementById('screenDiscuss');
    if (!discuss) return;
    if (discuss.classList.contains('active')){
      setupDiscussForReveal();
    }
  }

  // Observe class changes on screenDiscuss to catch activation
  function watchDiscussActivation(){
    var discuss = document.getElementById('screenDiscuss');
    if (!discuss || discuss.__revealObserver) return;
    var obs = new MutationObserver(function(muts){
      for (var i=0;i<muts.length;i++){
        if (muts[i].type === 'attributes' && muts[i].attributeName === 'class'){
          if (discuss.classList.contains('active')){
            setupDiscussForReveal();
          }
        }
      }
    });
    obs.observe(discuss, { attributes:true });
    discuss.__revealObserver = obs;
  }

  // Also wrap window.show if available to be safe
  function attachShowHook(){
    if (typeof window.show === 'function' && !window.__showWrappedForReveal){
      var orig = window.show;
      window.show = function(id){
        var res = orig.apply(this, arguments);
        if (id === 'screenDiscuss'){ setupDiscussForReveal(); }
        return 
<script>
(function(){
  if (window.__revealOverlayV5) return;
  window.__revealOverlayV5 = true;

  function ensureOverlay(){
    // Place overlay directly under the buttons row (same panel)
    var panel = document.querySelector('#screenDiscuss .panel');
    if (!panel) return null;
    var existing = document.getElementById('revealOverlay');
    if (existing) return existing;
    var overlay = document.createElement('div');
    overlay.id = 'revealOverlay';
    // Insert right after the first row (buttons)
    var firstRow = panel.querySelector('.row');
    if (firstRow && firstRow.nextSibling){
      panel.insertBefore(overlay, firstRow.nextSibling);
    } else {
      panel.appendChild(overlay);
    }
    return overlay;
  }

  function hideVoteUI(){
    try{
      var votePanel = document.getElementById('votePanel');
      var voteList = document.getElementById('voteList');
      var voteScroll = document.getElementById('voteScroll');
      var voteTop = document.querySelector('#screenDiscuss .voteTop');
      var voteResult = document.getElementById('voteResult');
      var revealBox = document.getElementById('revealBox');
      if (voteTop) voteTop.style.display = 'none';
      if (votePanel) votePanel.style.display = 'none';
      if (voteList) { voteList.innerHTML = ''; voteList.style.display = 'none'; }
      if (voteScroll) voteScroll.style.display = 'none';
      if (voteResult) { voteResult.style.display = 'none'; voteResult.innerHTML=''; }
      if (revealBox) { revealBox.style.display = 'none'; revealBox.innerHTML=''; }
    }catch(e){}
  }

  function mapOrder(imps){
    // Return indices in order: col2,row1; col1,row1; col2,row2; col1,row2; ...
    var ordered = [];
    for (var r=0, i=0; i<imps.length; r++){
      ordered.push(imps[i++]);
      if (i >= imps.length) break;
      ordered.push(imps[i++]);
    }
    // But we want the first item to appear visually in the top-right.
    // We'll place cards alternately into columns by appending with CSS grid; for the visual,
    // we can reverse column order with CSS by placing the container in RTL direction.
    return ordered;
  }

  function revealOverlay(){
    try{
      hideVoteUI();
      var btnNewRound = document.getElementById('btnNewRound');
      var btnFinish = document.getElementById('btnFinishVote');
      if (btnFinish){ btnFinish.disabled = true; btnFinish.textContent = 'Aufgedeckt'; }

      var names = (window.state && Array.isArray(window.state.names)) ? window.state.names : [];
      var total = (window.state && +window.state.totalPlayers) || names.length;
      if (names.length < total){
        for (var i = names.length; i < total; i++){ names.push('Spieler ' + (i+1)); }
      }
      var imps = (window.state && (window.state.impostorIndices || (typeof window.state.impostorIndex === 'number' ? [window.state.impostorIndex] : []))) || [];

      var overlay = ensureOverlay();
      if (!overlay) return;
      overlay.innerHTML = '';
      overlay.className = 'show'; // base show

      if (imps.length === 1){
        overlay.classList.add('single');
        var idx = imps[0];
        var nm = names[idx] || ('Spieler ' + (idx+1));
        var big = document.createElement('div');
        big.className = 'cardBig';
        big.innerHTML = '<div>'+nm+'</div><div class="impBadge">Impostor</div>';
        overlay.appendChild(big);
      } else {
        overlay.classList.add('multi');
        var ordered = mapOrder(imps.slice(0)); // copy
        for (var k=0; k<ordered.length; k++){
          var idx = ordered[k];
          var nm = names[idx] || ('Spieler ' + (idx+1));
          var small = document.createElement('div');
          small.className = 'cardSmall';
          small.style.animationDelay = (120*k) + 'ms';
          small.innerHTML = '<div>'+nm+'</div><div class="impBadge">Impostor</div>';
          overlay.appendChild(small);
        }
      }
      if (btnNewRound){ btnNewRound.style.display = 'inline-block'; }
    }catch(e){ console.error('revealOverlay failed', e); }
  }

  // Override global reveal
  window.revealImpostors = revealOverlay;

  // Ensure the button calls it and is enabled
  function wireButton(){
    var btn = document.getElementById('btnFinishVote');
    if (btn){
      btn.disabled = false;
      btn.removeAttribute('disabled');
      btn.style.pointerEvents = 'auto';
      btn.onclick = function(){ revealOverlay(); };
      btn.textContent = 'Aufdecken';
    }
  }

  // Also ensure when screenDiscuss becomes active
  function watchDiscuss(){
    var discuss = document.getElementById('screenDiscuss');
    if (!discuss) return;
    var obs = new MutationObserver(function(muts){
      muts.forEach(function(m){
        if (m.type === 'attributes' && m.attributeName === 'class' && discuss.classList.contains('active')){
          wireButton();
        }
      });
    });
    obs.observe(discuss, { attributes:true });
    if (discuss.classList.contains('active')) wireButton();
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', function(){ wireButton(); watchDiscuss(); }, { once:true });
  } else {
    wireButton(); watchDiscuss();
  }
})();
</script>
res;
      };
      window.__showWrappedForReveal = true;
    }
  }

  function init(){
    attachShowHook();
    watchDiscussActivation();
    runIfActive();
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init, { once:true });
  } else {
    init();
  }
})();
</script>

<script>
(function(){
  if (window.__revealButtonFixV4) return;
  window.__revealButtonFixV4 = true;

  function enableRevealButton(){
    var btnFinish = document.getElementById('btnFinishVote');
    if (btnFinish){
      btnFinish.disabled = false;
      btnFinish.removeAttribute('disabled');
      btnFinish.style.pointerEvents = 'auto';
      btnFinish.textContent = 'Aufdecken';
      btnFinish.onclick = function(){
        try { window.revealImpostors && window.revealImpostors(); } catch(e){}
      };
    }
    var revealBox = document.getElementById('revealBox');
    if (revealBox){ revealBox.style.display = 'none'; revealBox.innerHTML=''; }
    var voteResult = document.getElementById('voteResult');
    if (voteResult){ voteResult.style.display = 'none'; voteResult.innerHTML=''; }
  }

  // Run when discuss becomes active
  function watchDiscuss(){
    var discuss = document.getElementById('screenDiscuss');
    if (!discuss) return;
    var obs = new MutationObserver(function(muts){
      muts.forEach(function(m){
        if (m.type === 'attributes' && m.attributeName === 'class'){
          if (discuss.classList.contains('active')){
            enableRevealButton();
          }
        }
      });
    });
    obs.observe(discuss, { attributes:true });
    // Also run now if already active
    if (discuss.classList.contains('active')){
      enableRevealButton();
    }
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', watchDiscuss, { once:true });
  } else {
    watchDiscuss();
  }
})();
</script>

<script>
(function(){
  if (window.__revealFallbackV6) return;
  window.__revealFallbackV6 = true;

  function ensureContainersVisible(){
    var panel = document.getElementById('votePanel');
    var scroll = document.getElementById('voteScroll');
    var list = document.getElementById('voteList');
    var top = document.querySelector('#screenDiscuss .voteTop');
    // Show the panel but hide the toolbar
    if (panel){ panel.style.display = 'block'; }
    if (top){ top.style.display = 'none'; }
    if (scroll){ scroll.style.display = 'block'; scroll.style.maxHeight = 'unset'; }
    if (list){ list.style.display = 'block'; list.innerHTML = ''; }
    // Hide legacy text boxes
    var revealBox = document.getElementById('revealBox');
    var voteResult = document.getElementById('voteResult');
    if (revealBox){ revealBox.style.display = 'none'; revealBox.innerHTML=''; }
    if (voteResult){ voteResult.style.display = 'none'; voteResult.innerHTML=''; }
  }

  function makeCardEl(name, big, delayMs){
    var d = document.createElement('div');
    d.className = big ? 'revealCard big' : 'revealCard small';
    d.style.animationDelay = (delayMs||0)+'ms';
    d.innerHTML = '<div>'+name+'</div><div class="revealTag">Impostor</div>';
    return d;
  }

  function renderIntoVoteList(names, imps){
    ensureContainersVisible();
    var list = document.getElementById('voteList');
    if (!list) return;

    // Style list as our reveal grid
    if (imps.length === 1){
      list.className = ''; // reset
      list.style.display = 'grid';
      list.style.gridTemplateColumns = '1fr';
      list.style.justifyItems = 'center';
      list.innerHTML = '';
      var nm = names[imps[0]] || ('Spieler ' + (imps[0]+1));
      var big = makeCardEl(nm, true, 0);
      list.appendChild(big);
    } else {
      list.className = ''; // reset
      list.style.display = 'grid';
      list.style.gridTemplateColumns = 'repeat(2, minmax(140px, 220px))';
      list.style.gap = '12px';
      list.style.justifyContent = 'center';
      list.innerHTML = '';
      for (var k=0; k<imps.length; k++){
        var idx = imps[k];
        var nm = names[idx] || ('Spieler ' + (idx+1));
        var card = makeCardEl(nm, false, 120*k);
        list.appendChild(card);
      }
    }
  }

  // Override reveal function with robust fallback
  var originalReveal = window.revealImpostors;
  window.revealImpostors = function(){
    try{
      // Compute names and impostors
      var names = (window.state && Array.isArray(window.state.names)) ? window.state.names.slice(0) : [];
      var total = (window.state && +window.state.totalPlayers) || names.length;
      if (names.length < total){
        for (var i = names.length; i < total; i++){ names.push('Spieler ' + (i+1)); }
      }
      var imps = (window.state && (window.state.impostorIndices || (typeof window.state.impostorIndex === 'number' ? [window.state.impostorIndex] : []))) || [];

      // First try overlay if defined
      if (typeof originalReveal === 'function'){
        try { originalReveal(); } catch(e){}
      }

      // After a short delay, check if any card is visible; if not, render into voteList
      setTimeout(function(){
        var anyCard = document.querySelector('.revealCard, .cardBig, .cardSmall');
        if (!anyCard){
          renderIntoVoteList(names, imps);
        }
        // Ensure New Round button appears
        var nr = document.getElementById('btnNewRound');
        if (nr) nr.style.display = 'inline-block';
        var fin = document.getElementById('btnFinishVote');
        if (fin){ fin.disabled = true; fin.textContent = 'Aufgedeckt'; }
      }, 60);
    }catch(e){ console.error('revealFallbackV6 failed', e); }
  };

  // Guarantee the button is bound
  function wireButton(){
    var btn = document.getElementById('btnFinishVote');
    if (btn){
      btn.disabled = false;
      btn.removeAttribute('disabled');
      btn.style.pointerEvents = 'auto';
      btn.textContent = 'Aufdecken';
      btn.onclick = function(){ window.revealImpostors(); };
    }
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', wireButton, { once:true });
  } else {
    wireButton();
  }
})();


// === Reveal Big Card logic (fade-in, ~1cm margin) ===
function showImpostorCard() {
  const overlay = document.getElementById('revealOverlay');
  if (!overlay) return;

  const word = (state && state.current && state.current.word) ? state.current.word : '—';

  // Support 1 or multiple impostors
  let impIndices = [];
  if (state && Array.isArray(state.impostorIndices)) {
    impIndices = state.impostorIndices;
  } else if (state && typeof state.impostorIndex === 'number') {
    impIndices = [state.impostorIndex];
  }
  if (!impIndices.length) impIndices = [0];

  const impNames = impIndices.map(i => (state && state.names && state.names[i]) ? state.names[i] : `Spieler ${i+1}`);

  overlay.innerHTML = `
    <div class="cardBig">
      <div class="revealTitle">IMPOSTOR${impNames.length > 1 ? 'S' : ''} AUFGEDECKT</div>
      <div>
        ${impNames.map(n => `<div class="revealTagBig">🕵️‍♂️ ${n}</div>`).join('')}
      </div>
      <div class="revealWord">Gesuchtes Wort: <b>${word}</b></div>
    </div>
  `;
  overlay.classList.add('show');
}

(function attachRevealListener(){
  const btn = document.getElementById('btnFinishVote');
  if (btn) {
    btn.addEventListener('click', showImpostorCard, { passive: true });
  } else {
    // If button not yet in DOM, retry shortly after DOM ready
    document.addEventListener('DOMContentLoaded', () => {
      const b = document.getElementById('btnFinishVote');
      if (b) b.addEventListener('click', showImpostorCard, { passive: true });
    });
  }
})();

</script>

<script>
// === Session-only settings persistence & New Round reload ===
(function(){
  // Save current state into sessionStorage so a plain refresh keeps settings,
  // but closing the tab/browser wipes them.
  function saveSettings(){
    try{
      if (typeof state !== 'undefined') {
        sessionStorage.setItem('imposterSettings', JSON.stringify(state));
      }
    }catch(e){ console.warn('saveSettings failed:', e); }
  }

  function loadSettings(){
    try{
      const saved = sessionStorage.getItem('imposterSettings');
      if (saved && typeof state !== 'undefined'){
        Object.assign(state, JSON.parse(saved));
      }
    }catch(e){ console.warn('loadSettings failed:', e); }
  }

  function syncUI(){
    try{
      if (typeof badge === 'function') badge();
      const pn = document.getElementById('playerNum');
      const dt = document.getElementById('dealTotal');
      if (pn) pn.textContent = state.totalPlayers;
      if (dt) dt.textContent = state.totalPlayers;
      if (typeof buildNameInputs === 'function') buildNameInputs();
      // Update impostor slider limits if function exists in your code
      if (typeof updateImpostorSliderLimits === 'function') updateImpostorSliderLimits();
      // Reflect game mode button text if available
      const modeBtn = document.getElementById('btnShuffle');
      if (modeBtn && state.gameMode) {
        modeBtn.textContent = 'Spielmodus: ' + state.gameMode;
      }
    }catch(e){ console.warn('syncUI failed:', e); }
  }

  function init(){
    // Load any saved state first
    loadSettings();
    // Sync the UI to the loaded state
    syncUI();

    // Wire up "Neue Runde" to refresh the page
    const newRoundBtn = document.getElementById('btnNewRound');
    if (newRoundBtn){
      newRoundBtn.addEventListener('click', () => {
        // ensure latest state is saved before reloading
        saveSettings();
        location.reload();
      }, { once: false });
    }

    // Save state on tab refresh/close
    window.addEventListener('beforeunload', saveSettings);
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init, { once: true });
  } else {
    // DOM already ready
    init();
  }
})();
</script>

<script>
// === Fix: keep impostor count persisted & in sync with slider ===
(function(){
  function clampImpostors(val, players){
    val = parseInt(val||1,10);
    players = parseInt(players||3,10);
    const max = Math.max(1, players - 1);
    if (val < 1) val = 1;
    if (val > max) val = max;
    return { val, max };
  }
  function applyImpostorUI(){
    try{
      const slider = document.getElementById('impostorSlider');
      const cnt = document.getElementById('impostorCount');
      const maxLbl = document.getElementById('impostorMaxLabel');
      if (!slider) return;
      const players = (typeof state !== 'undefined' && state.totalPlayers) ? state.totalPlayers : 3;
      const { val, max } = clampImpostors((state && state.totalImpostors) ? state.totalImpostors : slider.value, players);
      slider.min = '1';
      slider.max = String(max);
      slider.value = String(val);
      if (cnt) cnt.textContent = slider.value;
      if (maxLbl) maxLbl.textContent = slider.max;
      if (typeof state !== 'undefined'){
        state.totalImpostors = val;
      }
    }catch(e){ console.warn('applyImpostorUI failed:', e); }
  }
  function persist(){
    try{
      if (typeof state !== 'undefined'){
        sessionStorage.setItem('imposterSettings', JSON.stringify(state));
      }
    }catch(e){}
  }
  function init(){
    applyImpostorUI();
    const slider = document.getElementById('impostorSlider');
    const cnt = document.getElementById('impostorCount');
    if (slider){
      slider.addEventListener('input', function(){
        if (typeof state !== 'undefined'){
          state.totalImpostors = parseInt(this.value,10) || 1;
        }
        if (cnt) cnt.textContent = this.value;
        persist();
      });
      slider.addEventListener('change', persist);
    }
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init, { once:true });
  } else {
    init();
  }
})();
</script>


<script>
// === Multi-Impostor Reveal UI ===
(function(){
  function getImpostorIndices(){
    try{
      if (Array.isArray(state?.impostorIndices) && state.impostorIndices.length){
        return state.impostorIndices.slice();
      }
      if (typeof state?.impostorIndex === 'number'){
        return [state.impostorIndex];
      }
    }catch(e){}
    return [];
  }

  function getPlayerName(i){
    try{
      return (state?.names?.[i] && String(state.names[i]).trim()) || `Spieler ${i+1}`;
    }catch(e){
      return `Spieler ${i+1}`;
    }
  }

  function ensureRevealArea(){
    let area = document.getElementById('revealArea');
    if (!area){
      const discuss = document.getElementById('screenDiscuss');
      if (discuss){
        area = document.createElement('div');
        area.id = 'revealArea';
        discuss.appendChild(area);
      }
    }
    return area;
  }

  function showSingle(name){
    const overlay = document.getElementById('revealOverlay');
    if (!overlay) return;
    overlay.innerHTML = `
      <div class="cardBig">
        <div class="revealTitle">IMPOSTOR</div>
        <div class="revealWord">${name}</div>
        <div class="revealTagBig">Erwischt</div>
      </div>
    `;
    overlay.classList.add('show');
  }

  function showMultiple(names){
    const overlay = document.getElementById('revealOverlay');
    if (overlay){ overlay.classList.remove('show'); overlay.innerHTML = ''; }
    const area = ensureRevealArea();
    if (!area) return;
    area.className = 'multi'; // 2 Spalten
    area.innerHTML = '';
    names.forEach((n, idx) => {
      const card = document.createElement('div');
      card.className = 'revealCard small';
      card.style.animationDelay = (0.05 * idx) + 's';
      card.innerHTML = `${n}<div class="revealTag">Impostor</div>`;
      area.appendChild(card);
    });
  }

  function revealImpostors(){
    const total = parseInt(state?.totalImpostors || 1, 10);
    const idxs = getImpostorIndices();
    const names = (idxs.length ? idxs : [state?.impostorIndex ?? 0]).map(getPlayerName);

    if (total <= 1 || names.length <= 1){
      showSingle(names[0] || 'Unbekannt');
    } else {
      showMultiple(names);
    }
  }

  function hookFinishButton(){
    const btn = document.getElementById('btnFinishVote');
    if (!btn) return;
    // Avoid double-binding
    if (btn.dataset.multiRevealBound === '1') return;
    btn.dataset.multiRevealBound = '1';

    btn.addEventListener('click', function(){
      // Let existing logic run first, then render reveal cards.
      setTimeout(revealImpostors, 0);
    });
  }

  function init(){
    hookFinishButton();
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init, { once:true });
  } else {
    init();
  }
})();
</script>


<script>
// === Grow the Vote screen's top button bar downward on "Auflösen" click ===
(function(){
  // Find the first panel inside the vote screen and flag it as the "reveal bar"
  var discuss = document.getElementById('screenDiscuss');
  if (!discuss) return;
  var topPanel = discuss.querySelector('.panel');
  if (!topPanel) return;
  topPanel.classList.add('revealbar'); // used by the CSS above

  var btn = document.getElementById('btnFinishVote'); // "Auflösen" button
  if (!btn) return;
  btn.addEventListener('click', function(){
    // Only expand once; leave it that way
    topPanel.classList.add('expanded');
  }, { passive: true });
})();
</script>


<script>
(function(){
  function pxPerCm(){
    var el = document.createElement('div');
    el.style.cssText = 'position:absolute; left:-9999px; top:-9999px; height:1cm; width:1px;';
    document.body.appendChild(el);
    var px = el.getBoundingClientRect().height || 37.8; // fallback ~37.8px/cm
    el.remove();
    return px;
  }
  var ONE_CM = pxPerCm();

  var discuss = document.getElementById('screenDiscuss');
  if (!discuss) return;
  var topPanel = discuss.querySelector('.panel');
  if (!topPanel) return;
  topPanel.classList.add('revealbar');

  function expandPanelTo(targetBottomPx){
    // Expand the top panel so its visual bottom reaches targetBottomPx (viewport coords)
    var rect = topPanel.getBoundingClientRect();
    var styles = getComputedStyle(topPanel);
    var currPB = parseFloat(styles.paddingBottom) || 0;
    var delta = targetBottomPx - rect.bottom;
    var newPB = Math.max(currPB + delta, 0);
    topPanel.style.paddingBottom = newPB + 'px';
  }

  function setOverlayTopToPanel(){
    var overlay = document.getElementById('revealOverlay');
    if (!overlay) return;
    if (!overlay.classList.contains('show')) return;
    // After padding change, position overlay just below panel
    var raf = window.requestAnimationFrame;
    raf(function(){
      var rect = topPanel.getBoundingClientRect();
      overlay.style.top = (rect.bottom + 8) + 'px'; // small gap
    });
  }

  function handleBigOverlay(){
    var overlay = document.getElementById('revealOverlay');
    if (!overlay) return false;
    if (!overlay.classList.contains('show')) return false;
    var card = overlay.querySelector('.cardBig');
    if (!card) return false;
    // Target: almost bottom – leave ~1cm margin
    var margin = Math.max(ONE_CM, 16);
    var targetBottom = window.innerHeight - margin;
    expandPanelTo(targetBottom);
    return true;
  }

  function handleSmallCards(){
    // If there is a grid of small reveal cards, grow until bottom of the last card + 1cm.
    var area = document.getElementById('revealArea');
    if (!area) return false;
    var cards = area.querySelectorAll('.revealCard.small');
    if (!cards.length) return false;
    // Wait for layout/animations to settle a tick, then measure
    requestAnimationFrame(function(){
      var maxBottom = 0;
      cards.forEach(function(c){
        var r = c.getBoundingClientRect();
        if (r.bottom > maxBottom) maxBottom = r.bottom;
      });
      var targetBottom = maxBottom + ONE_CM; // +1cm
      // But don't exceed viewport bottom minus a tiny margin
      targetBottom = Math.min(targetBottom, window.innerHeight - 8);
      expandPanelTo(targetBottom);
    });
    return true;
  }

  function recompute(){
    // Try small cards first (more specific), else big overlay
    if (handleSmallCards()) return;
    if (handleBigOverlay()) return;
  }

  // Hook up "Auflösen" click – expand and compute, leave expanded
  var btn = document.getElementById('btnFinishVote');
  if (btn){
    btn.addEventListener('click', function(){
      // Initial grow (in case reveal shows immediately after)
      topPanel.classList.add('expanded');
      // Try recompute immediately and again shortly after for any animations
      recompute();
      setTimeout(recompute, 120);
      setTimeout(recompute, 320);
      setTimeout(recompute, 700);
    }, { passive: true });
  }

  // Observe overlay visibility and revealArea content to recompute dynamically
  var overlay = document.getElementById('revealOverlay');
  if (overlay){
    new MutationObserver(function(){
      recompute();
      }).observe(overlay, { attributes: true, childList: true, subtree: true });
  }
  var area = document.getElementById('revealArea');
  if (area){
    new MutationObserver(function(){
      recompute();
    }).observe(area, { childList: true, subtree: true });
  }

  // Recompute on resize to keep alignment
  window.addEventListener('resize', function(){ setTimeout(recompute, 60); }, { passive:true });
})();
</script>


<script>
/* === Multi-Reveal ins Overlay heben, damit die expandierende Bar nicht verschiebt === */
(function(){
  const overlay = document.getElementById('revealOverlay');
  if (!overlay) return;

  function moveMultiToOverlay(area){
    if (!area || !overlay) return;
    // Wenn bereits im Overlay, am besten zurücksetzen
    overlay.classList.add('show','multi');
    // Leeren & Grid-Wrapper erstellen
    overlay.innerHTML = '';
    const grid = document.createElement('div');
    grid.className = 'gridWrap';
    overlay.appendChild(grid);

    // Karten verschieben
    const cards = Array.from(area.querySelectorAll('.revealCard.small'));
    cards.forEach(card => {
      grid.appendChild(card);
    });

    // Originalbereich aus dem Flow nehmen
    area.style.display = 'none';
  }

  function restoreFromOverlay(area){
    if (!area || !overlay) return;
    if (!overlay.classList.contains('multi')) return;

    // Karten zurück in den Bereich schieben (falls nötig)
    const grid = overlay.querySelector('.gridWrap');
    if (grid){
      const cards = Array.from(grid.children);
      cards.forEach(card => area.appendChild(card));
    }
    // Overlay Multi-Status entfernen
    overlay.classList.remove('multi');
    // Wenn kein Single-Reveal aktiv, Overlay ganz ausblenden
    if (!overlay.classList.contains('show-single')){
      overlay.classList.remove('show');
      overlay.innerHTML = '';
    }
    area.style.display = '';
  }

  // Beobachte DOM-Änderungen, um #revealArea.multi zu erkennen
  const mo = new MutationObserver((mutations)=>{
    for (const m of mutations){
      // Suche nach Erscheinen/Verändern von #revealArea
      const area = document.getElementById('revealArea');
      if (!area) continue;

      const isMulti = area.classList.contains('multi');
      const hasCards = area.querySelector('.revealCard.small');

      // Wenn Multi-Kacheln vorhanden sind, ins Overlay verschieben
      if (isMulti && hasCards){
        moveMultiToOverlay(area);
      } else {
        // Falls nicht mehr multi, alles zurück
        if (!isMulti){
          restoreFromOverlay(area);
        }
      }
    }
  });

  mo.observe(document.documentElement, { childList: true, subtree: true, attributes: true, attributeFilter: ['class'] });

  // Fallback: bei Seitenwechseln / Screen-Wechseln ebenfalls rücksetzen
  window.addEventListener('hashchange', ()=>{
    const area = document.getElementById('revealArea');
    if (area) restoreFromOverlay(area);
  });
})();
</script>


<script>
/* === COMBINED PATCH: neutralize showVoteResult and hide existing text === */
(function(){
  try {
    window.showVoteResult = function(){
      var el = document.getElementById('voteResult');
      if (el){
        el.style.display = 'none';
        el.textContent = '';
      }
      var box = document.getElementById('revealBox');
      if (box){
        box.style.display = 'none';
        if (box.firstElementChild) box.firstElementChild.textContent = '';
      }
    };
    // Also hide immediately on load just in case
    document.addEventListener('DOMContentLoaded', function(){
      var el = document.getElementById('voteResult');
      if (el){ el.style.display = 'none'; el.textContent = ''; }
      var box = document.getElementById('revealBox');
      if (box){ box.style.display = 'none'; if (box.firstElementChild) box.firstElementChild.textContent = ''; }
    });
  } catch(e){}
})();
</script>






<script>
/* === SINGLE REVEAL: robust overlay observer with delayed fall-in & persistence === */
(function(){
  const overlay = document.getElementById('revealOverlay');
  const revealBar = document.querySelector('#screenDiscuss .panel.revealbar');
  if (!overlay) return;

  function isMulti(){
    return overlay.classList.contains('multi') ||
           overlay.querySelector('.gridWrap') ||
           overlay.querySelector('.revealCard.small');
  }
  function currentBigCard(){
    return overlay.querySelector('.cardBig');
  }
  function whenBarExpanded(cb){
    // Consider expanded when class 'expanded' is present OR padding-bottom is > 0
    if (!revealBar){ setTimeout(cb, 420); return; }
    const expandedNow = () => {
      const cs = getComputedStyle(revealBar);
      const pb = parseFloat(cs.paddingBottom || "0");
      return revealBar.classList.contains('expanded') || pb > 0;
    };
    const trigger = () => setTimeout(cb, 380); // extra delay before card appears

    if (expandedNow()){
      trigger();
      return;
    }
    let fired = false;
    const onEnd = (e)=>{
      if (fired) return;
      if (e && e.propertyName && e.propertyName !== 'padding-bottom') return;
      fired = true;
      revealBar.removeEventListener('transitionend', onEnd);
      trigger();
    };
    revealBar.addEventListener('transitionend', onEnd);
    // Watch for class/style changes too
    const mo = new MutationObserver(()=>{
      if (expandedNow()){
        mo.disconnect();
        if (!fired){
          fired = true;
          trigger();
        }
      }
    });
    mo.observe(revealBar, { attributes: true, attributeFilter: ['class','style'] });
    // Hard fallback if nothing fires
    setTimeout(()=>{
      if (!fired){
        fired = true;
        trigger();
      }
    }, 1100);
  }

  function fallIn(card){
    // Make visible and animate once. Do not hide again.
    card.style.visibility = "visible";
    card.style.opacity = "1";
    // reset any previous animation classes
    card.classList.remove('pop-in');
    card.classList.remove('fall-in');
    void card.offsetWidth; // reflow
    card.classList.add('fall-in');
  }

  function prepareHidden(card){
    // Avoid flash if card just got inserted
    card.style.opacity = "0";
    card.style.visibility = "hidden";
    card.style.transform = "translateY(-28px) scale(0.98)";
  }

  // Handle every insertion / replacement of the big card
  function handle(){
    if (isMulti()) return; // not for multi
    const card = currentBigCard();
    if (!card) return;

    // Immediately hide to prevent early flash from app code
    prepareHidden(card);

    // After bar fully expanded (plus a small delay), fall it in
    whenBarExpanded(()=>{
      // If during the wait the card was replaced, re-handle
      const fresh = currentBigCard();
      if (!fresh) return;
      if (fresh !== card){
        prepareHidden(fresh);
        fallIn(fresh);
        return;
      }
      fallIn(card);
    });
  }

  // Observe overlay for any changes to its children
  const obs = new MutationObserver(()=>{
    // Every time DOM changes, attempt to handle the current big card
    handle();
  });
  obs.observe(overlay, { childList: true, subtree: true });

  // Initial attempt on load and shortly after
  window.addEventListener('DOMContentLoaded', handle);
  setTimeout(handle, 60);
  setTimeout(handle, 260);
})();
</script>



<script>
/* === Old edge line logic: capture pre-expand bottom and keep a fixed line there === */
(function(){
  const line = document.getElementById('oldEdgeLine');
  const btnReveal = document.getElementById('btnFinishVote');
  const revealBar = document.querySelector('#screenDiscuss .panel.revealbar');

  if (!line || !btnReveal || !revealBar) return;

  let measuredY = null;

  // On click of "Auflösen": measure the current bottom of the reveal bar BEFORE it expands
  btnReveal.addEventListener('click', function(){
    try {
      const rect = revealBar.getBoundingClientRect();
      measuredY = Math.round(rect.bottom); // viewport Y of the old bottom edge
      // place and show the line
      line.style.top = measuredY + 'px';
      line.style.display = 'block';
    } catch(e){}
  }, { capture: true }); // capture to run before potential class toggles

  // Optional: hide the line when leaving the screen or starting a new round
  const btnNewRound = document.getElementById('btnNewRound');
  if (btnNewRound){
    btnNewRound.addEventListener('click', ()=>{
      line.style.display = 'none';
    });
  }
})();
</script>













<script>
/* === Multi-Reveal: pop AFTER bar finishes, using CSS .prehide gating === */
(function(){
  if (window.__multiAfterBarV2) return; window.__multiAfterBarV2 = true;

  function waitForRevealBar(cb){
    try{
      var bar = document.querySelector('#screenDiscuss .panel.revealbar');
      if(!bar){ setTimeout(cb, 360); return; }
      var expandedNow = function(){
        var cs = getComputedStyle(bar);
        var pb = parseFloat(cs.paddingBottom || "0");
        return bar.classList.contains('expanded') || pb > 0.5;
      };
      var fired = false;
      var fire = function(){ if(fired) return; fired = true; setTimeout(cb, 60); };
      if (expandedNow()){ fire(); return; }
      var onEnd = function(e){
        if (e && e.propertyName && e.propertyName !== 'padding-bottom') return;
        bar.removeEventListener('transitionend', onEnd);
        fire();
      };
      bar.addEventListener('transitionend', onEnd);
      var mo = new MutationObserver(function(){ if (expandedNow()){ mo.disconnect(); fire(); } });
      mo.observe(bar, { attributes:true, attributeFilter:['class','style'] });
      setTimeout(fire, 1200);
    }catch(_){ setTimeout(cb, 420); }
  }

  function tagAsPrehide(card){
    if(!card || !(card.classList && card.classList.contains('revealCard'))) return;
    if (!card.classList.contains('small')) return; // only small/multi
    card.classList.add('prehide');
    try{ card.style.animationDelay = '0ms'; }catch(_){}
    try{ card.style.animation = 'none'; }catch(_){}
  }
  function showCard(card){
    if(!card) return;
    try{ card.style.animationDelay = '0ms'; }catch(_){}
    card.classList.remove('prehide');
    // restart any CSS animation declared on .revealCard
    card.style.animation = 'none';
    void card.offsetWidth;
    card.style.animation = '';
  }

  var armed = false;
  var obs = null;

  function arm(){
    armed = true;
    document.querySelectorAll('.revealCard.small').forEach(tagAsPrehide);
    if (!obs){
      obs = new MutationObserver(function(muts){
        if (!armed) return;
        for (var i=0;i<muts.length;i++){
          var m = muts[i];
          if (!m.addedNodes) continue;
          for (var j=0;j<m.addedNodes.length;j++){
            var n = m.addedNodes[j];
            if (n && n.nodeType === 1){
              if (n.matches && n.matches('.revealCard.small')) tagAsPrehide(n);
              var inner = n.querySelectorAll ? n.querySelectorAll('.revealCard.small') : [];
              inner.forEach(tagAsPrehide);
            }
          }
        }
      });
    }
    obs.observe(document.documentElement, { childList:true, subtree:true });

    waitForRevealBar(function(){
      // choose final parent after any overlay move
      var parent = document.querySelector('#revealOverlay.multi .gridWrap') ||
                   document.getElementById('revealArea') ||
                   document.querySelector('#voteList') ||
                   document;
      var cards = Array.from(parent.querySelectorAll('.revealCard.small'));
      // If none found yet, take a broader query (in case moving happens late)
      if (!cards.length) cards = Array.from(document.querySelectorAll('.revealCard.small'));
      cards.forEach(function(card, i){
        setTimeout(function(){ showCard(card); }, 120 * i);
      });
      // disarm after the sequence
      setTimeout(function(){
        armed = false;
        try{ obs && obs.disconnect(); }catch(_){}
      }, 120 * cards.length + 800);
    });
  }

  function isMulti(){
    try{
      if (!window.state) return false;
      var imps = (state.impostorIndices && state.impostorIndices.length)
        ? state.impostorIndices
        : (typeof state.impostorIndex === 'number' ? [state.impostorIndex] : []);
      return imps && imps.length > 1;
    }catch(_){ return false; }
  }

  function bind(){
    var btn = document.getElementById('btnFinishVote');
    if (!btn) return false;
    btn.addEventListener('click', function(){
      if (isMulti()) arm();
    }, { capture:true });
    return true;
  }

  if (!bind()){
    document.addEventListener('DOMContentLoaded', bind, { once:true });
  }
})();
</script>


<script>
(function(){
  function ready(fn){ if(document.readyState!=="loading"){ fn(); } else { document.addEventListener("DOMContentLoaded", fn, {once:true}); } }
  ready(function(){
    var finishBtn = document.getElementById("btnFinishVote");
    if(!finishBtn) return;
    var row = finishBtn.parentNode;
    if(row){ row.style.position = row.style.position || "relative"; }

    var oldNew = document.getElementById("btnNewRound");
    if(oldNew){
      oldNew.id = "btnNewRoundHidden";
      oldNew.style.display = "none";
      oldNew.setAttribute("aria-hidden","true");
    }

    var newBtn = document.createElement("button");
    newBtn.id = "btnNewRound";
    newBtn.className = "btn btn-green btn-center newround-hidden";
    newBtn.textContent = "Neue Runde";
    if(row) row.appendChild(newBtn);

    function syncSize(){
      try{
        var cs = window.getComputedStyle(finishBtn);
        newBtn.style.padding = cs.padding;
        newBtn.style.borderRadius = cs.borderRadius;
        newBtn.style.fontSize     = cs.fontSize;
        newBtn.style.fontWeight   = cs.fontWeight || "800";
        newBtn.style.minWidth     = cs.minWidth;
      }catch(e){}
    }

    function placeNewAtFinish(){
      var rowRect = row.getBoundingClientRect();
      var finRect = finishBtn.getBoundingClientRect();
      var left = finRect.left - rowRect.left + row.scrollLeft;
      var top  = finRect.top  - rowRect.top  + row.scrollTop;
      newBtn.style.position = "absolute";
      newBtn.style.left = left + "px";
      newBtn.style.top  = top  + "px";
      newBtn.style.width = finRect.width + "px";
    }

    syncSize();
    placeNewAtFinish();
    window.addEventListener("resize", function(){ syncSize(); placeNewAtFinish(); });

    function afterVanish(cb){
      var done = false;
      function onEnd(e){
        if(e && e.target !== finishBtn) return;
        if(done) return;
        done = true;
        finishBtn.removeEventListener('animationend', onEnd);
        cb();
      }
      finishBtn.addEventListener('animationend', onEnd);
      setTimeout(function(){ if(!done){ done = true; finishBtn.removeEventListener('animationend', onEnd); cb(); } }, 420);
    }

    finishBtn.addEventListener("click", function(){
      finishBtn.classList.add("btn-vanish-out");
      afterVanish(function(){
        finishBtn.classList.add("finish-hidden");
        placeNewAtFinish();
        newBtn.classList.remove("newround-hidden");
        newBtn.classList.add("newround-visible");
      });
    });

    newBtn.addEventListener("click", function(){
      var hidden = document.getElementById("btnNewRoundHidden");
      if(hidden){ hidden.click(); }
    });
  });
})();
</script>


<script>
(function(){
  state.startIndex = 0;
  state.revealedStarter = false;

  function pickStarter(){
    state.names = [...document.querySelectorAll('#namesWrap input')].map((el,i)=> el.value.trim() || `Spieler ${i+1}`);
    if(state.names.length < state.totalPlayers){
      for(let i=state.names.length; i<state.totalPlayers; i++) state.names.push(`Spieler ${i+1}`);
    }
    state.startIndex = Math.floor(Math.random() * state.totalPlayers);
    renderStarterCard();
  }

  function renderStarterCard(){
    const idx = state.startIndex;
    const nm  = (state.names[idx] || ('Spieler ' + (idx+1))).toUpperCase();
    const inner = document.getElementById('coverInnerStart');
    const big   = document.getElementById('starterNameBig');
    if(big) big.textContent = 'STARTER';
    try{
      const [c1, c2] = CARD_COLORS[idx % CARD_COLORS.length];
      if(inner) inner.style.background = `linear-gradient(160deg, ${c1}, ${c2})`;
    }catch(_){}
    const wEl = document.getElementById('starterWordOut');
    const sEl = document.getElementById('starterSubOut');
    if(wEl){ wEl.textContent = nm; wEl.classList.remove('impostor'); }
    if(sEl){ sEl.textContent = 'Du startest. Gib nach dem Aufdecken mit „Weiter“ an den Karten-Screen.'; }
    hideStarterButtons();
    const card = document.getElementById('coverCardStart');
    if(card){ card.classList.remove('flip-tilt','release'); }
    state.revealedStarter = false;
  }

  function hideStarterButtons(){
    const rr = document.getElementById('btnStarterReroll');
    const go = document.getElementById('btnStarterGo');
    [rr,go].forEach(b=>{
      if(!b) return;
      b.style.visibility='hidden'; b.style.opacity='0'; b.style.transform='translateY(14px)';
      b.disabled = true;
    });
    try{ document.body.classList.remove('starter-anchored'); }catch(e){}
  }
  function showStarterButtons(){
    const rr = document.getElementById('btnStarterReroll');
    const go = document.getElementById('btnStarterGo');
    [rr,go].forEach(b=>{
      if(!b) return;
      b.style.visibility='visible'; b.style.opacity='1'; b.style.transform='translateY(0)';
      b.disabled = false;
    });
    try{ requestAnimationFrame(()=> document.body.classList.add('starter-anchored')); }catch(e){}
  }

  (function(){
    const THRESH = 30;
    const inner = document.getElementById('coverInnerStart');
    const card  = document.getElementById('coverCardStart');
    const scr   = document.getElementById('screenStarter');
    if(!inner || !card || !scr) return;
    let startY = 0, dragging = false, reached = false;
    function getUnderlay(){ return card.querySelector('.underlay'); }
    function tiltOn(){ if(!card.classList.contains('flip-tilt')) card.classList.add('flip-tilt'); }
    function tiltOff(){ if(card.classList.contains('flip-tilt')){ card.classList.add('release'); setTimeout(()=> card.classList.remove('flip-tilt','release'), 360); } }
    function onDown(e){ if(!scr.classList.contains('active')) return; dragging = true; reached = false; startY = (e.touches ? e.touches[0].clientY : e.clientY) || 0; }
    function onMove(e){ if(!dragging) return; const y = (e.touches ? e.touches[0].clientY : (e.clientY || startY)); const delta = startY - y; if(delta >= THRESH && !reached){ reached = true; state.revealedStarter = true; tiltOn(); try{ const u = getUnderlay(); if(u){ u.style.visibility=''; u.style.opacity=''; } document.body.classList.remove('underlay-hidden'); }catch(_){}}}
    function onUp(){
  if(!dragging) return;
  dragging = false;
  if(reached){
    showStarterButtons();
  }else{
    hideStarterButtons();
    tiltOff();
    try{
      if(card){
        card.classList.add('bottom-shrink');
        card.addEventListener('animationend', ()=> card.classList.remove('bottom-shrink'), { once:true });
      }
    }catch(e){}
  }
}
    inner.addEventListener('mousedown', onDown, {passive:true});
    inner.addEventListener('touchstart', onDown, {passive:true});
    window.addEventListener('mousemove', onMove, {passive:true});
    window.addEventListener('touchmove', onMove, {passive:true});
    window.addEventListener('mouseup', onUp, {passive:true});
    window.addEventListener('touchend', onUp, {passive:true});
    new MutationObserver(()=>{ if(!scr.classList.contains('active')){ tiltOff(); hideStarterButtons(); } }).observe(scr, { attributes:true, attributeFilter:['class'] });
  })();

  
  // --- Pull-to-reveal for Starter (same as Deal logic) ---
  (function(){
    const inner = document.getElementById('coverInnerStart');
    const coverCardEl = document.getElementById('coverCardStart');
    const scr = document.getElementById('screenStarter');
    if(!inner || !coverCardEl || !scr) return;

    let dragging=false, startY=0, currentY=0, pull=0;
    const THRESH=30; const MAXPULL=window.innerHeight*0.7;

    function onPointerDown(e){
      if(!scr.classList.contains('active')) return;
      dragging = true;
      startY = (e.touches ? e.touches[0].clientY : e.clientY);
      currentY = startY;
      inner.style.transition = 'none';
    }
    function onPointerMove(e){
      if(!dragging) return;
      currentY = (e.touches ? e.touches[0].clientY : e.clientY);
      pull = Math.min(0, currentY - startY);
      pull = Math.max(pull, -MAXPULL);
      inner.style.transform = `translateY(${pull}px)`;
      if(pull < 0){
        coverCardEl && coverCardEl.classList.add('stretching');
      } else {
        coverCardEl && coverCardEl.classList.remove('stretching');
      }
      if(pull < -THRESH && !state.revealedStarter){
        state.revealedStarter = true;
        try{ navigator.vibrate && navigator.vibrate(10) }catch(_){}
      }
    }
    function onPointerUp(){
      if(!dragging) return;
      dragging = false;
      inner.style.transition = 'transform .45s cubic-bezier(.22,1,.36,1)';
      inner.style.transform = 'translateY(0)';
      pull = 0;
      coverCardEl && coverCardEl.classList.remove('stretching');
      if(state.revealedStarter){ showStarterButtons(); } else { hideStarterButtons(); try{ if(coverCardEl){ coverCardEl.classList.add('bottom-shrink'); coverCardEl.addEventListener('animationend', ()=> coverCardEl.classList.remove('bottom-shrink'), { once:true }); } }catch(e){} }
    }
    inner.addEventListener('mousedown', onPointerDown);
    inner.addEventListener('touchstart', onPointerDown, { passive:true });
    window.addEventListener('mousemove', onPointerMove, { passive:true });
    window.addEventListener('touchmove', onPointerMove, { passive:true });
    window.addEventListener('mouseup', onPointerUp, { passive:true });
    window.addEventListener('touchend', onPointerUp, { passive:true });

    // Reset when screen hidden
    new MutationObserver(()=>{
      if(!scr.classList.contains('active')){
        inner.style.transition = '';
        inner.style.transform = '';
        coverCardEl.classList.remove('stretching');
        state.revealedStarter = false;
        hideStarterButtons();
      }
    }).observe(scr, { attributes:true, attributeFilter:['class'] });
  })();

  document.getElementById('btnStarterCancel')?.addEventListener('click', ()=>{ show('screenStart'); });
  document.getElementById('btnStarterReroll')?.addEventListener('click', ()=>{ pickStarter(); });
  document.getElementById('btnStarterGo')?.addEventListener('click', ()=>{
    state.currentIndex = state.startIndex;
    
    state.dealtCount = 1; // added: first card shown for starter
try{
      document.getElementById('dealTotal').textContent = String(state.totalPlayers);
      document.getElementById('dealIndex').textContent = String(state.currentIndex + 1);
          setPlayerName(state.currentIndex);
    setCardColor(state.currentIndex);
if(typeof setUnderlayContent === 'function') setUnderlayContent();
    }catch(_){}
    show('screenDeal');
  });

  (function watchStarterActivation(){
    const scr = document.getElementById('screenStarter');
    if(!scr) return;
    new MutationObserver((muts)=>{
      muts.forEach(m=>{
        if(m.attributeName==='class' && scr.classList.contains('active')){
          pickStarter();
        }
      });
    }).observe(scr, { attributes:true, attributeFilter:['class'] });
  })();
})();
</script>


<script>
(function(){
  const btn = document.getElementById('btnStarterGo');
  if(!btn) return;
  btn.addEventListener('click', ()=>{
    try{
      const dealScreen = document.getElementById('screenDeal');
      if(dealScreen){
        dealScreen.classList.add('deal-slide-in');
        dealScreen.addEventListener('animationend', ()=>{
          dealScreen.classList.remove('deal-slide-in');
        }, { once:true });
      }
    }catch(_){}
  });
})();
</script>


<script>
(function(){
  const body = document.body;
  const slider = document.getElementById('impostorSlider');
  const countLabel = document.getElementById('impostorCount');

  function applyOneImpClass(val){
    const isOne = Number(val) === 1;
    body.classList.toggle('one-imp', isOne);
  }

  if (slider) applyOneImpClass(slider.value || 1);

  slider?.addEventListener('input', e => applyOneImpClass(e.target.value));
  slider?.addEventListener('change', e => applyOneImpClass(e.target.value));

  if (countLabel) {
    const obs = new MutationObserver(() => applyOneImpClass(countLabel.textContent.trim()));
    obs.observe(countLabel, { characterData: true, subtree: true, childList: true });
  }
})();
</script>


<script>
(function(){
  const body = document.body;
  function applyOneImpClass(val){
    const isOne = Number(val) === 1;
    body.classList.toggle('one-imp', isOne);
  }
  function initOneImp(){
    const slider = document.getElementById('impostorSlider');
    const countLabel = document.getElementById('impostorCount');
    if (slider) applyOneImpClass(slider.value || 1);
    slider?.addEventListener('input', e => applyOneImpClass(e.target.value));
    slider?.addEventListener('change', e => applyOneImpClass(e.target.value));
    if (countLabel) {
      const obs = new MutationObserver(() => applyOneImpClass(countLabel.textContent.trim()));
      obs.observe(countLabel, { characterData: true, subtree: true, childList: true });
    }
  }
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initOneImp, { once:true });
  } else {
    initOneImp();
  }
})();
</script>

<script>

// ==== Verdeckter Impostor: Effekt-Schutz ====

function impostorEffectsAllowed() {

  try { return (state && state.gameMode !== 'Verdeckter Impostor' && state.gameMode !== 'Blind Impostor'); } catch(e) { return true; }

}

function clearImpostorEffects() {

  var w = document.getElementById('wordOut');

  var s = document.getElementById('subOut');

  if (w) {

    w.classList.remove('impostor','impostorGlow','danger','shake','glitch','pulse','red','warning');

    w.removeAttribute('data-impostor');

    w.style.removeProperty('filter');

    w.style.removeProperty('text-shadow');

    w.style.removeProperty('color');

  }

  if (s) { s.textContent = ''; }

  document.body && document.body.classList && document.body.classList.remove('impostorMode','dangerMode');

  var root = document.documentElement;

  if (root && root.style) {

    ['--impostor-color','--impostor-shadow','--glow-color'].forEach(function(v){ root.style.removeProperty(v); });

  }

  try { if (window.impostorParticles && typeof window.impostorParticles.stop==='function') window.impostorParticles.stop(); } catch(e) {}

  try { if (typeof stopImpostorParticles === 'function') stopImpostorParticles(); } catch(e) {}

  try { if (typeof cancelImpostorAnimation === 'function') cancelImpostorAnimation(); } catch(e) {}

}


</script>
</body>
</html>